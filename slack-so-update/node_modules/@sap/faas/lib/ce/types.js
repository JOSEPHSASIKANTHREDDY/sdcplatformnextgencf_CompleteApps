'use strict';

const mime = require('content-type');
const {URL} = require('url');
const {EC, ErrMsg} = require('../errors');

const REQ = true;
const OPT = false;
const INLINE = true;
const BINARY = false;

module.exports = {
    readString,
    writeString,
    readTime,
    writeTime,
    readURI,
    writeURI,
    readData,
    writeData,
    writeExtensions,
    readJsonFormat,
    writeJsonFormat,
    REQ,
    OPT,
    INLINE,
    BINARY
};

function readString(ce, field, key, value, required) {
    if (typeof value === 'string' && value !== '') {
        ce[field] = value;
    } else if (required) {
        throw ErrMsg(EC.CE_INVALID_VALUE, key, 'string', value, typeof value);
    }
}

function writeString(ce, field, to, key, required) {
    const value = ce[field];
    if (typeof value === 'string' && value !== '') {
        to[key] = value;
    } else if (required) {
        throw ErrMsg(EC.CE_INVALID_VALUE, key, 'string', value, typeof value);
    }
}

function readTime(ce, field, key, value, required) {
    if (value) {
        try {
            const d = new Date(value);
            d.toISOString();                              // real validation
            ce[field] = d;
        } catch (e) {
            throw ErrMsg(EC.CE_INVALID_VALUE, key, 'timestamp', value, e.message);
        }
    } else if (required) {
        throw ErrMsg(EC.CE_INVALID_VALUE, key, 'timestamp', value, typeof value);
    }
}

function writeTime(ce, field, to, key, required) {
    const value = ce[field];
    if (value) {
        try {
            to[key] = (new Date(value)).toISOString();
        } catch (e) {
            throw ErrMsg(EC.CE_INVALID_VALUE, key, 'timestamp', value, e.message);
        }
    } else if (required) {
        throw ErrMsg(EC.CE_INVALID_VALUE, key, 'timestamp', value, 'value is required');
    }
}

function readURI(ce, field, key, value, required) {
    if (value) {
        try {
            ce[field] = new URL(value);
        } catch (e) {
            throw ErrMsg(EC.CE_INVALID_VALUE, key, 'URI', value, e.message);
        }
    } else if (required) {
        throw ErrMsg(EC.CE_INVALID_VALUE, key, 'URI', value, typeof value);
    }
}

function writeURI(ce, field, to, key, required) {
    let value = ce[field];
    if (value) {
        try {
            to[key] = new URL(value).toString();
        } catch (e) {
            throw ErrMsg(EC.CE_INVALID_VALUE, key, 'URI', value, e.message);
        }
    } else if (required) {
        throw ErrMsg(EC.CE_INVALID_VALUE, key, 'URI', value, 'value is required');
    }
}

function readData(ce, field, key, value, base64) {
    try {
        if (value === undefined) {
            return;
        }
        if (typeof value === 'string') {
            value = readBase64(key, value, base64);
        }
        if (jsonMime(ce, false)) {
            if (Buffer.isBuffer(value)) {
                value = JSON.parse(value.toString());
            } else if (typeof value === 'string') {
                value = JSON.parse(value);
            }
        }
        ce[field] = value;
    } catch(e) {
        throw ErrMsg(EC.CE_INVALID_DATA, ce.dataContentType, typeof value, e.message);
    }
}

function readBase64(key, value, mode) {
    switch (mode) {
        case true:
            return Buffer.from(value, 'base64');
        case undefined:
            return value;
        default:
            return value;
    }
}

function writeData(ce, field, to, key, inline) {
    let value = ce[field];
    if (value === undefined) {
        return;
    }
    const k = Array.isArray(key) ? key : [key, key]; // as of v1.0, inline (structured) uses two different names

    if (inline) {
        if (Buffer.isBuffer(value)) {
            to[k[1]] = (/** @type {Buffer} */ (value)).toString('base64');
        } else if (jsonData(value) && jsonMime(ce, true)) {
            to[k[0]] = value;
        } else if (typeof value === 'string') {      // simple string with any non JSON mime type
            to[k[0]] = value;
        } else {
            throw ErrMsg(EC.CE_INVALID_DATA, ce.dataContentType, typeof value, 'type mismatch');
        }
    } else {
        if (Buffer.isBuffer(value)) {
            to[k[0]] = (/** @type {Buffer} */ (value));
        } else if (jsonData(value) && jsonMime(ce, true)) {
            try {
                to[k[0]] = Buffer.from(JSON.stringify(value));
            } catch(e) {
                throw ErrMsg(EC.CE_INVALID_DATA, ce.dataContentType, typeof value, e.message);
            }
            if (!ce.dataContentType) {         // convenience for JSON data
                ce.dataContentType = 'application/json';
            }
        } else if (typeof value === 'string') {      // simple string with any non JSON mime type
            to[k[0]] = Buffer.from(value);
        } else {
            throw ErrMsg(EC.CE_INVALID_DATA, ce.dataContentType, typeof value, 'type mismatch');
        }
    }
}

function writeExtensions(ce, to, prefix) {
    if (!ce.extensions) {
        return;
    }
    if (typeof ce.extensions !== 'object') {
        throw ErrMsg(EC.CE_INVALID_VALUE, 'extensions', 'object', ce.extensions, 'type not supported');
    }
    const p = prefix || '';
    for (let [key, val] of Object.entries(ce.extensions)) {
        to[p + key] = val;
    }
}

function jsonData(value) {
    if (Array.isArray(value)) {
        return true;
    } else switch(typeof value) {
        case 'object':  // means also null
            return true;
        case 'string':
            return true;
        case 'number':
            return true;
        case 'boolean':
            return true;
    }
    return false;
}

function jsonMime(ce, implicit) {
    const ct = ce.dataContentType;
    if (ct) {
        const mt = ct ? mime.parse(ct).type : '';
        return mt === 'application/json' || mt.endsWith('+json');
    }
    return implicit;
}

/**
 * @param {Payload} payload
 * @return {{}}
 */
function readJsonFormat(payload) {
    switch (typeof payload) {
        case 'object':
            if (payload === null) {
                throw ErrMsg(EC.CE_INVALID_PAYLOAD, 'null');
            } else if (Buffer.isBuffer(payload)) {
                try {
                    return JSON.parse(payload.toString());
                } catch (e) {
                    throw ErrMsg(EC.CE_INVALID_PAYLOAD, e.message);
                } // jshint ignore:line
            } else if (payload.constructor === Object) {
                return payload;
            }
            throw ErrMsg(EC.CE_INVALID_PAYLOAD, 'object');
        case 'string':
            try {
                return JSON.parse(payload);
            } catch (e) {
                throw ErrMsg(EC.CE_INVALID_PAYLOAD, e.message);
            } // jshint ignore:line
        default:
            throw ErrMsg(EC.CE_INVALID_PAYLOAD, typeof payload);
    }
}

function writeJsonFormat(ce) {
    try {
        return Buffer.from(JSON.stringify(ce));
    } catch(e) {
        throw ErrMsg(EC.CE_INVALID_PAYLOAD, e.message);
    }
}
