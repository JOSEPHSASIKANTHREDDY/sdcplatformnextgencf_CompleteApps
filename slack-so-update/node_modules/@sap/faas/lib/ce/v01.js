'use strict';

/**
 * https://github.com/cloudevents/spec/blob/v0.1/spec.md
 */

const {readString, writeString, readTime, writeTime, readURI, writeURI, readData, writeData, writeExtensions, writeJsonFormat, REQ, OPT, INLINE, BINARY} = require('./types');

module.exports = {
    decodeJsonFormat,
    decodeHttpBinary,
    encodeJsonFormat,
    encodeHttpBinary
};

/**
 * @param {CloudEvent} ce
 * @return {Buffer}
 */
function encodeJsonFormat(ce) {
    const to = {};
    writeExtensions(ce, to, '');
    writeData(  ce, 'data',            to, 'data',            INLINE);
    writeString(ce, 'specVersion',     to, 'cloudEventsVersion', REQ);
    writeString(ce, 'source',          to, 'source',             REQ);
    writeString(ce, 'type',            to, 'eventType',          REQ);
    writeString(ce, 'id',              to, 'eventID',            REQ);
    writeTime(  ce, 'time',            to, 'eventTime',          OPT);
    writeURI(   ce, 'dataSchema',      to, 'schemaURL',          OPT);
    writeString(ce, 'dataContentType', to, 'contentType',        OPT);
    return writeJsonFormat(to);
}

/**
 * @param {{}} from
 * @return {CloudEvent}
 */
function decodeJsonFormat(from) {
    const ce = /** @type {CloudEvent} */ ({extensions: {}});
    for (let [key, val] of Object.entries(from)) {
        switch (key) {
            case 'cloudEventsVersion' : readString(ce, 'specVersion',     key, val, REQ); continue;
            case 'source'             : readString(ce, 'source',          key, val, REQ); continue;
            case 'eventType'          : readString(ce, 'type',            key, val, REQ); continue;
            case 'eventID'            : readString(ce, 'id',              key, val, REQ); continue;
            case 'eventTime'          : readTime(  ce, 'time',            key, val, OPT); continue;
            case 'schemaURL'          : readURI(   ce, 'dataSchema',      key, val, OPT); continue;
            case 'contentType'        : readString(ce, 'dataContentType', key, val, OPT); continue;
            case 'eventTypeVersion'   : /* ignore */    continue;
            case 'data'               : /* skip here */ continue;
            default:
                ce.extensions[key] = val;
        }
    }
    readData(ce, 'data', 'data', from['data'], undefined);
    return ce;
}

/**
 * @param {CloudEvent} ce
 * @return {{headers: {}, payload: Buffer}}
 */
function encodeHttpBinary(ce) {
    const headers = {};
    const result = {headers: headers, payload: null};
    writeExtensions(ce, headers, 'ce-x-');
    writeData(  ce, 'data',            result , 'payload',            BINARY);
    writeString(ce, 'specVersion',     headers, 'ce-cloudeventsversion', REQ);
    writeString(ce, 'source',          headers, 'ce-source',             REQ);
    writeString(ce, 'type',            headers, 'ce-eventtype',          REQ);
    writeString(ce, 'id',              headers, 'ce-eventid',            REQ);
    writeTime(  ce, 'time',            headers, 'ce-eventtime',          OPT);
    writeURI(   ce, 'dataSchema',      headers, 'ce-schemaurl',          OPT);
    writeString(ce, 'dataContentType', headers, 'content-type',          OPT);
    return result;
}

/**
 * @param {{}} headers
 * @param {Payload} payload
 * @return {CloudEvent}
 */
function decodeHttpBinary(headers, payload) {
    const ce = /** @type {CloudEvent} */ ({extensions: {}});
    for (const [k, val] of Object.entries(headers)) {
        if (k.match(/^ce-x-+/)) {
            ce.extensions[k.substring(5)] = headers[k];
            continue;
        }
        if (k.match(/^ce-+/)) {
            const key = k.substring(3);
            switch (key) {
                case 'eventtypeversion'   : /* ignore */ continue;
                case 'cloudeventsversion' : readString(ce, 'specVersion',     key, val, REQ); continue;
                case 'source'             : readString(ce, 'source',          key, val, REQ); continue;
                case 'eventtype'          : readString(ce, 'type',            key, val, REQ); continue;
                case 'eventid'            : readString(ce, 'id',              key, val, REQ); continue;
                case 'eventtime'          : readTime(  ce, 'time',            key, val, OPT); continue;
                case 'schemaurl'          : readURI(   ce, 'dataSchema',      key, val, OPT);
            }
        } else {
            switch (k) {
                case 'content-type'       : readString(ce, 'dataContentType', k,   val, OPT); continue;
                default:
                    break;
            }
        }
    }
    readData(ce, 'data', 'data', payload, false);
    return ce;
}
