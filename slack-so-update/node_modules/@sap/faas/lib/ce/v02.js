'use strict';

/**
 * https://github.com/cloudevents/spec/blob/v0.2/spec.md
 */

const {readString, writeString, readTime, writeTime, readURI, writeURI, readData, writeData, writeExtensions, writeJsonFormat, REQ, OPT, INLINE, BINARY} = require('./types');

module.exports = {
    decodeJsonFormat,
    decodeHttpBinary,
    encodeJsonFormat,
    encodeHttpBinary
};

/**
 * @param {CloudEvent} ce
 * @return {Buffer}
 */
function encodeJsonFormat(ce) {
    const to = {};
    writeExtensions(ce, to, '');
    writeData(  ce, 'data',            to, 'data',     INLINE);
    writeString(ce, 'specVersion',     to, 'specversion', REQ);
    writeString(ce, 'source',          to, 'source',      REQ);
    writeString(ce, 'type',            to, 'type',        REQ);
    writeString(ce, 'id',              to, 'id',          REQ);
    writeTime(  ce, 'time',            to, 'time',        OPT);
    writeURI(   ce, 'dataSchema',      to, 'schemaurl',   OPT);
    writeString(ce, 'dataContentType', to, 'contenttype', OPT);
    return writeJsonFormat(to);
}

/**
 * @param {{}} from
 * @return {CloudEvent}
 */
function decodeJsonFormat(from) {
    const ce = /** @type {CloudEvent} */ ({extensions: {}});
    for (let [key, val] of Object.entries(from)) {
        switch (key) {
            case 'specversion' : readString(ce, 'specVersion',     key, val, REQ); continue;
            case 'source'      : readString(ce, 'source',          key, val, REQ); continue;
            case 'type'        : readString(ce, 'type',            key, val, REQ); continue;
            case 'id'          : readString(ce, 'id',              key, val, REQ); continue;
            case 'time'        : readTime(  ce, 'time',            key, val, OPT); continue;
            case 'schemaurl'   : readURI(   ce, 'dataSchema',      key, val, OPT); continue;
            case 'contenttype' : readString(ce, 'dataContentType', key, val, OPT); continue;
            case 'data'        : /* skip here */ continue;
            default:
                ce.extensions[key] = val;
        }
    }
    readData(ce, 'data', 'data', from['data'], undefined);
    return ce;
}

/**
 * @param {CloudEvent} ce
 * @return {{headers: {}, payload: Buffer}}
 */
function encodeHttpBinary(ce) {
    const headers = {};
    const result = {headers: headers, payload: null};
    writeExtensions(ce, headers, 'ce-');
    writeData(  ce, 'data',            result , 'payload',     BINARY);
    writeString(ce, 'specVersion',     headers, 'ce-specversion', REQ);
    writeString(ce, 'source',          headers, 'ce-source',      REQ);
    writeString(ce, 'type',            headers, 'ce-type',        REQ);
    writeString(ce, 'id',              headers, 'ce-id',          REQ);
    writeTime(  ce, 'time',            headers, 'ce-time',        OPT);
    writeURI(   ce, 'dataSchema',      headers, 'ce-schemaurl',   OPT);
    writeString(ce, 'dataContentType', headers, 'content-type',   OPT);
    return result;
}

/**
 * @param {{}} headers
 * @param {Payload} payload
 * @return {CloudEvent}
 */
function decodeHttpBinary(headers, payload) {
    const ce = /** @type {CloudEvent} */ ({extensions: {}});
    for (const [k, val] of Object.entries(headers)) {
        if (k.match(/^ce-+/)) {
            const key = k.substring(3);
            switch (key) {
                case 'specversion' : readString(ce, 'specVersion',     key, val, REQ); continue;
                case 'source'      : readString(ce, 'source',          key, val, REQ); continue;
                case 'type'        : readString(ce, 'type',            key, val, REQ); continue;
                case 'id'          : readString(ce, 'id',              key, val, REQ); continue;
                case 'time'        : readTime(  ce, 'time',            key, val, OPT); continue;
                case 'schemaurl'   : readURI(   ce, 'dataSchema',      key, val, OPT); continue;
                default:
                    ce.extensions[key] = val;
            }
        } else {
            switch (k) {
                case 'content-type': readString(ce, 'dataContentType', k,   val, OPT); continue;
                default:
                    break;
            }
        }
    }
    readData(ce, 'data', 'data', payload, false);
    return ce;
}
