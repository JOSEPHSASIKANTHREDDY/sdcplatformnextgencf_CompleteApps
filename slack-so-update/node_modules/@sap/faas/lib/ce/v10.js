'use strict';

/**
 * https://github.com/cloudevents/spec/blob/v1.0/spec.md
 */

const {EC, ErrMsg} = require('../errors');
const {readString, writeString, readTime, writeTime, readURI, writeURI, readData, writeData, writeExtensions, writeJsonFormat, REQ, OPT, INLINE, BINARY} = require('./types');

module.exports = {
    decodeJsonFormat,
    decodeHttpBinary,
    encodeJsonFormat,
    encodeHttpBinary
};

/**
 * @param {CloudEvent} ce
 * @return {Buffer}
 */
function encodeJsonFormat(ce) {
    const to = {};
    writeExtensions(ce, to, '');
    writeData(  ce, 'data',            to, ['data', 'data_base64'], INLINE);
    writeString(ce, 'specVersion',     to, 'specversion',              REQ);
    writeString(ce, 'source',          to, 'source',                   REQ);
    writeString(ce, 'type',            to, 'type',                     REQ);
    writeString(ce, 'id',              to, 'id',                       REQ);
    writeString(ce, 'subject',         to, 'subject',                  OPT);
    writeTime(  ce, 'time',            to, 'time',                     OPT);
    writeString(ce, 'dataContentType', to, 'datacontenttype',          OPT);
    writeURI(   ce, 'dataSchema',      to, 'dataschema',               OPT);
    return writeJsonFormat(to);
}

/**
 * @param {{}} from
 * @return {CloudEvent}
 */
function decodeJsonFormat(from) {
    const ce = /** @type {CloudEvent} */ ({extensions: {}});
    let plain = false, base64 = false;
    for (let [key, val] of Object.entries(from)) {
        switch (key) {
            case 'specversion'        : readString(ce, 'specVersion',     key, val, REQ); continue;
            case 'source'             : readString(ce, 'source',          key, val, REQ); continue;
            case 'type'               : readString(ce, 'type',            key, val, REQ); continue;
            case 'id'                 : readString(ce, 'id',              key, val, REQ); continue;
            case 'subject'            : readString(ce, 'subject',         key, val, OPT); continue;
            case 'time'               : readTime  (ce, 'time',            key, val, OPT); continue;
            case 'datacontenttype'    : readString(ce, 'dataContentType', key, val, OPT); continue;
            case 'dataschema'         : readURI   (ce, 'dataSchema',      key, val, OPT); continue;
            case 'data'               : plain  = true;  /* skip here */ continue;
            case 'data_base64'        : base64 = true;  /* skip here */ continue;
            default:
                ce.extensions[key] = val;
        }
    }
    if (plain && base64) {
        throw ErrMsg(EC.CE_INVALID_PAYLOAD, '"data" and "data_base64" must not be used in combination');
    } else if (plain) {
        readData(ce, 'data', 'data'       , from['data']       , false);
    } else if (base64) {
        readData(ce, 'data', 'data_base64', from['data_base64'], true );
    }
    return ce;
}

/**
 * @param {CloudEvent} ce
 * @return {{headers: {}, payload: Buffer}}
 */
function encodeHttpBinary(ce) {
    const headers = {};
    const result = {headers: headers, payload: null};
    writeExtensions(ce, headers, 'ce-');
    writeData(  ce, 'data',            result , 'payload',             BINARY);
    writeString(ce, 'specVersion',     headers, 'ce-specversion',         REQ);
    writeString(ce, 'source',          headers, 'ce-source',              REQ);
    writeString(ce, 'type',            headers, 'ce-type',                REQ);
    writeString(ce, 'id',              headers, 'ce-id',                  REQ);
    writeString(ce, 'subject',         headers, 'ce-subject',             OPT);
    writeTime(  ce, 'time',            headers, 'ce-time',                OPT);
    writeString(ce, 'dataContentType', headers, 'content-type',           OPT);
    writeURI(   ce, 'dataSchema',      headers, 'ce-dataschema',          OPT);
    return result;
}

/**
 * @param {{}} headers
 * @param {Payload} payload
 * @return {CloudEvent}
 */
function decodeHttpBinary(headers, payload) {
    const ce = /** @type {CloudEvent} */ ({extensions: {}});
    for (const k of Object.keys(headers)) {
        const val = headers[k];
        if (k.match(/^ce-+/)) {
            const key = k.substring(3);
            switch (key) {
                case 'specversion'        : readString(ce, 'specVersion',     key, val, REQ); continue;
                case 'source'             : readString(ce, 'source',          key, val, REQ); continue;
                case 'type'               : readString(ce, 'type',            key, val, REQ); continue;
                case 'id'                 : readString(ce, 'id',              key, val, REQ); continue;
                case 'subject'            : readString(ce, 'subject',         key, val, OPT); continue;
                case 'time'               : readTime(  ce, 'time',            key, val, OPT); continue;
                case 'dataschema'         : readURI(   ce, 'dataSchema',      key, val, OPT); continue;
                default:
                    ce.extensions[key] = val;
            }
        } else {
            switch (k) {
                /** optional */
                case 'content-type'       : readString(ce, 'dataContentType', k,   val, OPT); continue;
                default:
                    break;
            }
        }
    }
    readData(ce, 'data', 'data', payload, false);
    return ce;
}
