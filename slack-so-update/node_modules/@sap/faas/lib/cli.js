#!/usr/bin/env node

'use strict';

const path = require('path');
const fs = require('fs');
const flags = require('command-line-args');
const usage = require('command-line-usage');
const server = require('./http/server');
const { initDeployValues } = require('./sdk/values');
const { createProjectConfig, checkRuntime, checkName, getDeployFileName, toAbsolutePath, checkReplacementValues, isEmptyObject } = require('./sdk/config');
const { getHandler } = require('./runtime/invoker');
const { EC, ErrMsg } = require('./errors');
const pkgFile = require('../package');

const optDef = [
    {
        name: 'project-folder',
        alias: 'p',
        multiple: false,
        type: String,
        typeLabel: '{underline folder}',
        description: 'home of {italic faas.json}, omit if working underneath'
    },
    {
        name: 'function-name',
        alias: 'f',
        multiple: false,
        type: String,
        typeLabel: '{underline name}',
        description: 'optional, use this function only'
    },
    {
        name: 'deploy-values',
        alias: 'y',
        multiple: false,
        type: String,
        typeLabel: '{underline file}',
        description: 'values to replace in secret and config files'
    }
];


const cmdDef = [
    {
        name: 'command',
        type: String,
        defaultOption: true,
        defaultValue: 'help'
    }
];

const runDef = [
    {
        name: 'runtime-port',
        alias: 'r',
        multiple: false,
        type: Number,
        defaultValue: Number(process.env.FAAS_RUNTIME_PORT || 8080),
        description: 'where runtime server will be listening'
    },
    {
        name: 'control-port',
        alias: 'c',
        multiple: false,
        type: Number,
        defaultValue: Number(process.env.FAAS_CONTROL_PORT || 8082),
        description: 'where control server will be listening'
    }
];

function help() {
    return usage([
        {
            header: 'Faas runtime for node.js',
            content: 'Same runtime to test and debug locally as well as to run functions in k8s.'
        },
        {
            header: 'Commands',
            content: [
                {
                    name: 'run',
                    description: 'run function in local http server'
                },
                {
                    name: 'check',
                    description: 'check {italic faas.json} and project structure'
                },
                {
                    name: 'init',
                    description: 'init new project'
                },
                {
                    name: 'init-values',
                    description: 'init deploy value file, by default values.yaml'
                },
                {
                    name: 'help',
                    description: 'show usage'
                },
                {
                    name: 'version',
                    description: 'show version'
                },
            ]
        },
        {
            header: 'Options',
            optionList: optDef,
            tableOptions: {
                columns: [
                    {
                        name: 'option',
                        noWrap: true, width: 30
                    },
                    {
                        name: 'description',
                        width: 50
                    }
                ]
            }
        },
        {
            header: 'Run Options',
            optionList: runDef,
            tableOptions: {
                columns: [
                    {
                        name: 'option',
                        noWrap: true,
                        width: 30
                    },
                    {
                        name: 'description',
                        width: 50
                    }
                ]
            }
        }
    ]);
}

try {
    const { command, _unknown } = flags(cmdDef, { stopAtFirstUnknown: true });
    // noinspection JSCheckFunctionSignatures
    const options = flags(optDef.concat(runDef), { argv: _unknown || [] });

    // noinspection JSUnresolvedFunction
    switch (command.toLowerCase()) {
        case 'run': {
            run(readProject(options));
            break;
        }
        case 'check': {
            let cfg = readProject(options);
            const mismatchedObjs = checkReplacementValues(cfg.values, cfg.proData, cfg.proBase, true);
            if (isEmptyObject(mismatchedObjs.services) && isEmptyObject(mismatchedObjs.configs) && isEmptyObject(mismatchedObjs.secrets)) {
                console.log('âœ“ All checks performed successfully');
            }
            break;
        }
        case 'init': {
            initProject(options);
            break;
        }
        case 'init-values': {
            initValues(options);
            break;
        }
        case 'version': {
            console.log(`${pkgFile.name}@${pkgFile.version} on ${process.platform}(${process.arch}) node ${process.version}\n`);
            break;
        }
        default:
            console.log(help());
    }
} catch (e) {
    console.error(e.message);
    process.exit(1);
}

/**
 * @param {Config} cfg
 * @private
 */
function run(cfg) {
    const { rtmSrv, ctlSrv, fnList } = server.listen(cfg, (func, error, simple) => {
        console.error(simple ? error.message : error);
    });

    rtmSrv
        .on('listening', () => {
            console.log(`faas runtime server listening at port ${rtmSrv.address().port}\n`);
            for (const func of fnList) console.log(`function ${func}\t${cfg.fncUrl(func)}`);
        })
        .on('close', () => {
            console.log(`faas runtime server closed`);
        })
        ;

    if (ctlSrv) ctlSrv
        .on('listening', () => {
            console.log(`faas control server listening at port ${ctlSrv.address().port}`);
        })
        .on('close', () => {
            console.log(`faas control server closed`);
        })
        ;
}

/**
 * @param {Object} options
 * @return {Config}
 * @private
 */
function readProject(options) {
    const cfg = createProjectConfig(options);

    checkName('project', cfg.proData['project']);
    checkRuntime(cfg.proData['runtime']);

    for (const fncData of cfg.fncData) {
        getHandler(require(fncData.modFile), fncData);
    }

    const triggers = cfg.proData['triggers'];
    if (triggers) {
        if (typeof triggers !== 'object')
            throw ErrMsg(EC.TRG_LIST_TYPE, typeof triggers);
        for (const name of Object.getOwnPropertyNames(triggers)) {
            checkName('trigger', name);
            const data = triggers[name];

            switch (data.type) {
                case 'HTTP':

                    break;
                case 'Timer':

                    break;
                case 'AMQP':

                    break;
                case 'CloudEvents':

                    break;
                default:
                    throw ErrMsg(EC.TRG_TYPE_INVALID, name, data.type, 'HTTP, Timer, AMQP, CloudEvents');
            }
        }
    }

    return cfg;
}

/**
 * @param {Object} options
 * @private
 */
function initValues(options) {
    const cfg = readProject(Object.assign({}, options, { 'deploy-values': undefined }));
    const log = /** @type{Array<string>} */ ([]);
    const data = initDeployValues(cfg.srvKeys, cfg.secDirs, cfg.cfgDirs, log);

    if (log.length) {
        console.log('values collected with warnings:');
        console.log(log.join('\n'), '\n');
    }

    if (options['deploy-values']) {
        const file = getDeployFileName(cfg.proBase, options['deploy-values']);
        assureDirectory(path.dirname(file));
        fs.writeFileSync(file, data);
        console.log(`file saved: ${file}`);
    } else if (data) {
        console.log(`no file to save (use '-y'), example for 'values.yaml':\n\n${data}\n`);
    } else {
        console.log(`no values found, check project secret and config map definition`);
    }
}

/**
 * @param {Object} options
 * @private
 */
function initProject(options) {
    const folder = options['project-folder'];
    const target = folder ? toAbsolutePath(folder) : process.cwd();
    const source = path.dirname(require.resolve('../template/faas.json'));
    assureDirectory(target);
    if (fs.readdirSync(target).length > 0) {
        console.log('nothing changed, directory not empty:', target);
        return;
    }
    copyDir(source, target);
    fs.renameSync(path.join(target, '_package.json'), path.join(target, 'package.json'));
    fs.renameSync(path.join(target, '_gitignore'), path.join(target, '.gitignore'));
    console.log('project initialized (1 function, 1 secret, 1 http trigger):', target, '\n\nTODO: npm install');
}

/**
 * @param {string} source
 * @param {string} target
 * @private
 */
function copyDir(source, target) {
    assureDirectory(target);
    const items = fs.readdirSync(source);
    for (const item of items) {
        if (fs.statSync(path.join(source, item)).isDirectory()) {
            copyDir(path.join(source, item), path.join(target, item));
        } else {
            fs.copyFileSync(path.join(source, item), path.join(target, item));
        }
    }
}

/**
 * @param {string} name
 */
function assureDirectory(name) {
    try {
        fs.statSync(name);
    } catch (e) {
        const p = path.dirname(name);
        if (p !== name)
            assureDirectory(p);
        fs.mkdirSync(name);
    }
}

