'use strict';

const express = require('express');
const morgan = require('morgan');
const body = require('body-parser');

const Metrics = require('../runtime/metrics');
const { createInvoker } = require('../runtime/invoker');

const LOG_LINE = '[:date[web]] :status :response-time ms :res[content-length] bytes ":method :url HTTP/:http-version" :user-agent';

module.exports = {
    listen
};

/**
 * @callback FncLog
 * @param {string} func
 * @param {Error} error
 * @param {boolean} short
 * @private
 */

/**
 * @callback NotifyOfClose
 * @param done
 */

/**
 * @param {Config} config
 * @param {FncLog} fncLog
 * @param {boolean|function(*, *): boolean} skipLog
 * @return {{rtmSrv: *, ctlSrv: *, fnList: Array, close: NotifyOfClose }}
 * @private
 */
function listen(config, fncLog, skipLog = false) {
    const runtime = express();
    const control = (config.rtmPort === config.ctlPort) ? runtime : express();
    const fnBase = runtime === control ? '/run' : '';  // add runtime route if server is shared

    const fnData = config.fncData;
    const fnList = [];

    const metrics = new Metrics();
    const limit = Array.isArray(fnData) ? '' : fnData.maxBody.replace(/iB$/g, 'B').replace(/i$/g, 'B');

    control
        .get('/healthz', handleProbe)
        .get('/metrics', (req, res) => handleMetrics(req, res, metrics))
        .disable('x-powered-by')
    ;

    runtime
        .use(morgan(LOG_LINE, { immediate: false, skip: skipLog }))
        .use(body.json(       { limit: limit, inflate: true, type: ['application/json', '+json'], strict: false }))
        .use(body.text(       { limit: limit, inflate: true, type: ['text/plain'] }))
        .use(body.urlencoded( { limit: limit, inflate: true, type: ['application/x-www-form-urlencoded'], parameterLimit: 1000, extended: true }))
        .use(body.raw(        { limit: limit, inflate: true, type: ['*/*'] }))
        .use(handleCORS)
        .disable('x-powered-by')
    ;

    if (Array.isArray(fnData)) for (const fnItem of fnData) {
        runtime.route(`${fnBase}/${fnItem.fncName}/*`).all(createInvoker(config, metrics, fncLog, fnItem));
        fnList.push(fnItem.fncName);
    } else {
        runtime.route(`${fnBase}/*`).all(createInvoker(config, metrics, fncLog, fnData));
        fnList.push(fnData.fncName);
    }

    const ctlSrv = (runtime !== control) ? control.listen(config.ctlPort) : null;
    const rtmSrv = runtime.listen(config.rtmPort).once('listening', () => {
        config.fncUrl = selectEndpointBuilder(config.domain, rtmSrv.address().port, fnBase, fnData);
    });

    return { rtmSrv, ctlSrv, fnList, close: /**@type {NotifyOfClose}*/((done) => shutdown(rtmSrv, ctlSrv, done))};
}

function shutdown(rtmSrv, ctlSrv, done) {
    if (typeof done === 'function') {
        rtmSrv.once('close', done);
    }
    if (ctlSrv) {
        ctlSrv.once('close', () => rtmSrv.close());
        ctlSrv.close();
    } else {
        rtmSrv.close();
    }
}

function selectEndpointBuilder(domain, port, fnBase, fnData) {
    if (Array.isArray(fnData)) {
        return (func) => `http://${domain}:${port}${fnBase}/${func}/`;
    } else if (domain === 'localhost') {
        // noinspection JSUnusedLocalSymbols
        return (func) => `http://${domain}:${port}${fnBase}/`;
    } else {
        return (func) => `http://${func}.${domain}:${port}${fnBase}/`;
    }
}

/**
 * express request handler
 * @private
 */
function handleProbe(req, res) {
    res.status(200).send('OK');
}

/**
 * express request handler
 * @private
 */
function handleMetrics(req, res, metrics) {
    res.status(200);
    metrics.onHttpQuery(res);
}

/**
 * express request handler
 * @private
 */
function handleCORS(req, res, next) {
    res.header('Access-Control-Allow-Origin', '*');

    if (req.method === 'OPTIONS') {
        res.set('Access-Control-Allow-Methods', req.get('Access-Control-Request-Method'));
        res.set('Access-Control-Allow-Headers', req.get('Access-Control-Request-Headers'));
        res.status(200).send();
        return;
    }

    next();
}

