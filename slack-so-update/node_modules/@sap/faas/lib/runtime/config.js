'use strict';

const path = require('path');
const fs = require('fs');
const {createReader} = require('./reader');
const {EC, ErrMsg} = require('../errors');

const MAX_TIMEOUT_SECONDS = 180;
const MIN_TIMEOUT_SECONDS = 10;

module.exports = {
    createRuntimeConfig,
    getPackageDependencies,
    loadManifest,
    MAX_TIMEOUT_SECONDS,
    MIN_TIMEOUT_SECONDS
};

/**
 * @typedef {Object} Config
 * @property {string} runtime
 * @property {FncUrl} fncUrl
 * @property {FncData|Array<FncData>} fncData
 * @property {string} srvBase
 * @property {Map<string,string>} srvKeys
 * @property {Map<string,string>} secDirs
 * @property {Map<string,string>} cfgDirs
 * @property {FileCache} fsCache
 * @property {string} domain
 * @property {number} rtmPort
 * @property {number} ctlPort
 * @private
 */

/**
 * @typedef {Map<string, Buffer>} FileCache
 * @private
 */

/**
 * @callback FncUrl
 * @param {string} name
 * @return {string}
 * @private
 */

/**
 * @typedef {Object} FncData
 * @property {Object} globals
 * @property {string} fncName
 * @property {string} modFile
 * @property {string} handler
 * @property {boolean} httpApi
 * @property {Map<string,string>} depLibs
 * @property {Reader} reader
 * @property {number} timeout
 * @property {string} maxBody
 * @private
 */

/**
 * @typedef {Object} Reader
 * @property {boolean} asyncAccess
 * @property {function(string, function(Buffer))} serviceKey
 * @property {function(string, string, function(Buffer))} secretValue
 * @property {function(string, string, function(Buffer))} configValue
 * @property {function(string, string)} secretStream
 * @property {function(string, string)} configStream
 */

/**
 * @callback Mapper
 * @param {Buffer} data
 * @return {*}
 * @private
 */

/**
 * @param {Object} options
 * @param {?FileCache} fsCache
 * @return {Config}
 * @private
 */
function createRuntimeConfig(options, fsCache= new Map()) {
    const runtime = options['runtime-name'];
    const modFile = path.normalize(path.join(options['source-folder'], options['library-folder'] || `.`, options['module-file']));
    const pkgFile = path.normalize(path.join(options['source-folder'], 'package.json'));
    const timeout = Number(options['timeout-seconds'] || 180);
    const srvBase = checkDirStat(options['service-folder']);
    const srvKeys = srvBase ? getSrvKeyMap(options['service-map']) : new Map();
    const secBase = options['secret-folder'];
    const secDirs = getSubDirMap(secBase);
    const cfgBase = options['config-folder'];
    const cfgDirs = getSubDirMap(cfgBase);

    return /** @type{Config} */ ({
        runtime: runtime,
        fncData: {
            fncName: options['function-name'],
            modFile: modFile,
            handler: options['module-handler'],
            httpApi: !!options['enable-http-api'],
            depLibs: getPackageDependencies(pkgFile),
            reader : createReader(runtime, srvBase, srvKeys, secDirs, cfgDirs, fsCache),
            timeout: 1000 * (timeout > MAX_TIMEOUT_SECONDS ? MAX_TIMEOUT_SECONDS : timeout < MIN_TIMEOUT_SECONDS ? MIN_TIMEOUT_SECONDS : timeout),
            maxBody: options['body-byte-limit'] || '1MB'
        },
        srvBase: srvBase,
        srvKeys: srvKeys,
        secDirs: secDirs,
        cfgDirs: cfgDirs,
        fsCache: fsCache,
        domain : options['runtime-domain'] || 'localhost',
        rtmPort: Number(options['runtime-port'] || 0),
        ctlPort: Number(options['control-port'] || 0),
    });
}

/**
 * @param {string} pkgFile
 * @return {Map<string, string>}
 * @private
 */
function getPackageDependencies(pkgFile) {
    const { dependencies } = loadManifest(pkgFile);
    if (!dependencies)
        return new Map();
    if (typeof dependencies !== 'object')
        throw ErrMsg(EC.PACKAGE_DEP_ERROR, typeof dependencies);

    const depPath = path.join(path.dirname(pkgFile), 'node_modules');
    const depLibs = new Map();
    for (const name of Object.keys(dependencies)) {
        depLibs.set(name, path.join(depPath, name));
    }
    return depLibs;
}

/**
 * @param {string} file
 * @return {Object}
 * @private
 */
function loadManifest(file) {
    try {
        return JSON.parse(fs.readFileSync(file).toString());
    } catch(e) {
        throw ErrMsg(EC.FILE_NOT_VALID, file, e.message);
    }
}

/**
 * @param {string} dir
 * @return {string}
 */
function checkDirStat(dir) {
    try {
        return (fs.statSync(dir).isDirectory()) ? dir : '';
    } catch (e) {
        return '';
    }
}

/**
 * @param {string} val
 * @return {Map<string, string>}
 */
function getSrvKeyMap(val) {
    const result = new Map();
    try {
        for (const [name, data] of Object.entries(JSON.parse(val))) {
            result.set(name, `${data['type']}.${data['instance']}.${data['key']}`);
        }
    } catch(e) {
        result.clear();
    }
    return result;
}

/**
 * @param {string} dir
 * @return {Map<string,string>}
 * @private
 */
function getSubDirMap(dir) {
    const result = new Map();
    try {
        for (const item of fs.readdirSync(dir)) {
            const subDir = path.join(dir, item);
            if (fs.statSync(subDir).isDirectory()) {
                result.set(item, subDir);
            }
        }
    } catch(e) {
        result.clear();
    }
    return result;
}

