'use strict';

const http = require('http');
const url = require('url');
const mime = require('content-type');
const yaml = require('js-yaml');
const request = require('request');
const cloudevents = require('../ce');
const {EC, ErrMsg} = require('../errors');

module.exports = {
    createContext,
};


/**
 * @param {Config} cfg
 * @param {FncData} fncData
 * @return {Faas.Context|Faas.ContextSync}
 * @private
 */
function createContext(cfg, fncData) {
    const rval = !fncData.httpApi ? {} : {
        http: {
            getFunctionEndpoint: (name) => cfg.fncUrl(name), // resolve late (after server is listening)
        }
    };

    const meta = {
        funcName: fncData.fncName,
        timeoutMS: fncData.timeout,
    };

    const read = fncData.reader;
    if (read.asyncAccess) {
        return /** @type {Faas.Context} */ Object.freeze(Object.assign(rval, meta, {
            getServiceCredentials       : async (name) => read.serviceKey(name, asBuffer),
            getServiceCredentialsString : async (name) => read.serviceKey(name, asString),
            getServiceCredentialsJSON   : async (name) => read.serviceKey(name, asJSON  ),

            getSecretValue      : async (name, key) => read.secretValue(name, key, asBuffer),
            getSecretValueString: async (name, key) => read.secretValue(name, key, asString),
            getSecretValueJSON  : async (name, key) => read.secretValue(name, key, asJSON  ),
            getSecretValueYAML  : async (name, key) => read.secretValue(name, key, asYAML  ),

            getConfigValue      : async (name, key) => read.configValue(name, key, asBuffer),
            getConfigValueString: async (name, key) => read.configValue(name, key, asString),
            getConfigValueJSON  : async (name, key) => read.configValue(name, key, asJSON  ),
            getConfigValueYAML  : async (name, key) => read.configValue(name, key, asYAML  ),

            getSecretValueStream: async (name, key) => read.secretStream(name, key),
            getConfigValueStream: async (name, key) => read.configStream(name, key),

            callFunction        : async (name, content) => callFncPromise(cfg, name, content),
        }));
    } else {
        return /** @type {Faas.ContextSync} */ Object.freeze(Object.assign(rval, meta, {
            getServiceCredentials       : (name) => read.serviceKey(name, asBuffer),
            getServiceCredentialsString : (name) => read.serviceKey(name, asString),
            getServiceCredentialsJSON   : (name) => read.serviceKey(name, asJSON  ),

            getSecretValue      : (name, key) => read.secretValue(name, key, asBuffer),
            getSecretValueString: (name, key) => read.secretValue(name, key, asString),
            getSecretValueJSON  : (name, key) => read.secretValue(name, key, asJSON  ),
            getSecretValueYAML  : (name, key) => read.secretValue(name, key, asYAML  ),

            getConfigValue      : (name, key) => read.configValue(name, key, asBuffer),
            getConfigValueString: (name, key) => read.configValue(name, key, asString),
            getConfigValueJSON  : (name, key) => read.configValue(name, key, asJSON  ),
            getConfigValueYAML  : (name, key) => read.configValue(name, key, asYAML  ),

            getSecretValueStream: (name, key) => read.secretStream(name, key),
            getConfigValueStream: (name, key) => read.configStream(name, key),

            callFunction        : (name, content, callback) => typeof callback === 'function' ? callFncJsStyle(cfg, name, content, callback) : callFncPromise(cfg, name, content),
        }));
    }
}

/**
 * @param {Buffer} out
 * @return {Buffer}
 */
function asBuffer(out) {
    return out;
}

/**
 * @param {Buffer} out
 * @return {string}
 */
function asString(out) {
    return out.toString();
}

/**
 * @param {Buffer} out
 * @return {*}
 */
function asJSON(out) {
    return JSON.parse(out.toString());
}

/**
 * @param {Buffer} out
 * @return {*}
 */
function asYAML(out) {
    return yaml.safeLoad(out);
}

/**
 * @param {Config} config
 * @param {string} name
 * @param {Faas.Content} content
 * @returns {Promise<Faas.Content>}
 */
function callFncPromise(config, name, content) {
    return new Promise((resolve, reject) => {
        callFncJsStyle(config, name, content, (err, content) => {
            if (err) {
                reject(err);
            } else {
                resolve(content);
            }
        });
    });
}

/**
 * @param {Config} config
 * @param {string} name
 * @param {Faas.Content} content
 * @param {Faas.ContentHandler} callback
 */
function callFncJsStyle(config, name, content, callback) {
    const opt = newCallOptions(config, name, content);
    request(opt, (error, response, body) => {
        if (error) {
            callback(error, null);
        } else if (![200, 201, 202, 203, 204, 205].includes(response.statusCode)) {
            callback(ErrMsg(EC.CALL_POST_FAILED, name, response.statusCode, http.STATUS_CODES[response.statusCode]), null);
        } else {
            const ce = cloudevents.decodeHttp(response.headers, response.body);
            if (ce) {
                callback(null, {type: 'application/cloudevents+json', data: ce});
            } else {
                callback(null, {type: response.headers['content-type'], data: body});
            }
        }
    });
}

/**
 * @param {Config} config
 * @param {string} name
 * @param {Faas.Content} content
 * @return {Object}
 * @private
 */
function newCallOptions(config, name, content) {
    const opt = {
        uri: url.parse(config.fncUrl(name)),
        method: 'POST',
        headers: {},
    };

    if (content === undefined || content === null) {
        return opt;
    }

    if (typeof content !== 'object') {
        throw ErrMsg(EC.CALL_CONTENT_INVALID, name, 'content', typeof content);
    }

    if (typeof content.type === 'string') {
        try {
            mime.parse(content.type);
        } catch(e) {
            throw ErrMsg(EC.CALL_CONTENT_INVALID, name, 'content.type', typeof content.type);
        }
        setContentType(name, opt.headers, content.type);
    }

    const val = content.data;
    switch (typeof val) {
        case 'undefined':
            break;
        case 'object':
            if (val === null) {
                // opt.body = undefined;
            } else if (Buffer.isBuffer(val)) {
                opt.body = val;
                setContentType(name, opt.headers, 'application/octet-stream');
            } else if (Array.isArray(val)) {
                opt.body = val;
                opt.json = true;
            } else {
                switch (val.constructor.name) {
                    case 'Object':
                        opt.body = val;
                        opt.json = true;
                        break;
                    case 'String':
                        opt.body = val.valueOf();
                        setContentType(name, opt.headers, 'text/plain');
                        break;
                    case 'Number':
                        opt.body = val.valueOf();
                        opt.json = true;
                        break;
                    case 'Boolean':
                        opt.body = val.valueOf();
                        opt.json = true;
                        break;
                    default:
                        throw ErrMsg(EC.CALL_CONTENT_INVALID, name, 'content.data', val.constructor.name);
                }
            }
            break;
        case 'string':
            opt.body = val;
            setContentType(name, opt.headers, 'text/plain');
            break;
        case 'number':
            opt.body = val;
            opt.json = true;
            break;
        case 'boolean':
            opt.body = val;
            opt.json = true;
            break;
        default:
            throw ErrMsg(EC.CALL_CONTENT_INVALID, name, 'content.data', typeof val);
    }
    return opt;
}

/**
 * @param {Object} headers
 * @param {string} type
 * @param {string} func
 */
function setContentType(func, headers, type) {
    if (Object.hasOwnProperty('Content-Type')) return;   // keep existing value
    try {
        mime.parse(type);
    } catch(e) {
        throw ErrMsg(EC.CALL_CONTENT_INVALID, func, 'content.type', type);
    }
    headers['Content-Type'] = type;
}

