'use strict';

const cloudevents = require('../ce');
const mime = require('content-type');
const {PassThrough} = require('stream');
const OUT = Symbol('@sap/faas/event/response/stream');

/**
 * @callback BuildEvent
 * @param {object} request
 * @param {object} response
 * @return {Faas.Event}
 * @private
 */

/**
 * @param {FncData} fncData
 * @return {BuildEvent}
 * @private
 */
module.exports = function (fncData) {
    return fncData.httpApi ? newHttpEvent : newCoreEvent;
};

function newHttpEvent(request, response) {
    return Object.assign(newCoreEvent(request, response), {
        http: {
            request: request,
            response: response
        },
    });
}

function newCoreEvent(request, response) {
    const auth = decodeAuthorization(request);
    const base = newBaseEvent(request);
    return Object.assign(base, {
        auth: auth,
        decodeJsonWebToken: () => decodeJsonWebToken(auth),
        decodeUserPassword: () => decodeUserPassword(auth),
        setBadRequest: (info) => setBadRequest(response, info),
        setUnauthorized: (info) => setUnauthorized(response, info),
        getContentType: () => getContentType(base.ce, request),
        setResponseType: (type) => setResponseType(type, response),
        getResponseStream: (type) => getResponseStream(type, response, base),
        sendResponseEvent: (ce) => sendResponseEvent(ce, response),
    });
}

function newBaseEvent(request) {
    const ce = cloudevents.decodeHttp(request.headers, request.body);
    if (ce) {
        return {ce: ce, data: ce.data};
    }
    if (request.method === 'GET') {
        return {ce: null, data: request.query};
    }
    return {ce: null, data: request.body};
}

function decodeAuthorization(request) {
    const auth = request.get('authorization');
    const [type, cred] = typeof auth === 'string' ? auth.split(' ', 2) : ['', ''];
    return cred ? {type: type, credentials: cred} : {type: type, credentials: ''};
}

function decodeJsonWebToken(auth) {
    try {
        if (auth.type !== 'Bearer')
            return null;

        const segment = auth.credentials.split('.');
        if (segment.length !== 3)
            return null;

        return {
            header: JSON.parse(Buffer.from(segment[0], 'base64').toString('utf8')),
            payload: JSON.parse(Buffer.from(segment[1], 'base64').toString('utf8')),
            signature: segment[2]
        };
    } catch (e) {
        return null;
    }
}

function decodeUserPassword(auth) {
    try {
        if (auth.type !== 'Basic')
            return null;

        // noinspection JSCheckFunctionSignatures
        const [user, pwd] = Buffer.from(auth.credentials, 'base64').toString('ascii').split(':', 2);

        return {
            user: user,
            password: pwd
        };
    } catch (e) {
        return null;
    }
}

function getContentType(ce, request) {
    return ce ? ce.dataContentType : request.get('content-type');
}

function setResponseType(ct, response) {
    mime.parse(ct);
    response.set('content-type', ct);
}

function setBadRequest(response, info) {
    response.status(400).send(info);
}

function setUnauthorized(response, info) {
    response.status(401).send(info);
}

function getResponseStream(ct, response, base) {
    if (ct) {
        setResponseType(ct, response);
    }
    let rs = base[OUT];
    if (!rs) {
        rs = new PassThrough();
        rs.pipe(response, {end: true});
        base[OUT] = rs;
    }
    return rs;
}

function sendResponseEvent(ce, response) {
    const {headers, payload} = cloudevents.encodeHttp(ce);
    for (let [key, val] of Object.entries(headers)) {
        response.set(key, val);
    }
    response.send(payload);
}

