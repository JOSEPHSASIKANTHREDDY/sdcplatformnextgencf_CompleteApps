'use strict';

const path = require('path');
const fs = require('fs');
const http = require('http');
const vm = require('vm');
const Module = require('module');
const selectEventBuilder = require('./event');
const { createContext } = require('./context');
const {EC, ErrMsg} = require('../errors');

const FAAS = require('../../package').name;
const EXEC = `\n/* */\nrequire('${FAAS}')(module.exports);\n`;

module.exports = {
    createInvoker,
    getHandler,
};

/**
 * @param {Config} config
 * @param {Metrics} metrics
 * @param {FncLog} fncLog
 * @param {FncData} fncData
 * @return {function(request, response)}
 * @private
 */
function createInvoker(config, metrics, fncLog, fncData) {
    try {
        const modFile = fncData.modFile;
        const context = createContext(config, fncData);
        const evBuild = selectEventBuilder(fncData);
        const resolve = (file) => resolveFile(file, fncData);

        const sandbox = {
            __filename: modFile,
            __dirname: path.dirname(modFile),
            module: new Module(modFile, null),
        };
        const script = new vm.Script(fs.readFileSync(modFile) + EXEC, {
            filename: modFile,
            displayErrors: true,
            produceCachedData: true
        });

        return (request, response) => runSandbox(request, response, script, sandbox, metrics, context, evBuild, fncLog, fncData, resolve);
    } catch(e) {
        throw ErrMsg(EC.SCRIPT_LOAD_ERROR, e.message);
    }
}

function runSandbox(request, response, script, sandbox, metrics, context, evBuild, fncLog, fncData, resolve) {
    Error.stackTraceLimit = 10;

    const closer = metrics.onFuncStart(fncData.fncName, request.method);
    const event = evBuild(request, response);

    const failed = (error, code) => funcFailed(error, code, request, response, fncLog, fncData, metrics);
    const reject = (error, code) => funcFailed(error, code, request, response, fncLog, fncData, metrics);
    const finish = (result) => funcFinish(result, response, reject);
    const invoke = (modexp) => funcInvoke(modexp, event, context, finish, failed, fncData);

    response.on('finish', closer);
    response.on('removeListener', (e, h) => { if (e === 'finish' && h === closer) throw ErrMsg(EC.SCRIPT_EVENT_REMOVE); });

    try {
        const sbx = Object.assign(Object.create(global), sandbox);
        sbx.require = (name) => loadModule(name, invoke, fncData.modFile, fncData.depLibs);
        sbx.require.resolve = resolve;

        script.runInNewContext(sbx, {
            displayErrors: true,
            timeout: fncData.timeout
        });
    } catch (err) {
        if (err.toString().match('Error: Script execution timed out')) {
            failed(ErrMsg(EC.SCRIPT_TIMEOUT, fncData.timeout / 1000), 408);
        } else {
            failed(err, 500);
        }
    }
}

function resolveFile(file, fncData) {
    if (typeof file === 'string' && file.startsWith('.')) {
        return require.resolve(path.normalize(path.join(path.dirname(fncData.modFile), file)));
    }
    return require.resolve(file);
}

function loadModule(name, invoke, modFile, depLibs) {
    if (name === FAAS)
        return invoke;
    else if (depLibs.has(name))
        return require(depLibs.get(name));
    else if (name.indexOf('./') === 0 || name.indexOf('../') === 0)
        return require(path.normalize(path.join(path.dirname(modFile), name)));
    else
        return require(name);
}

function getHandler(modexp, fncData) {
    switch (typeof modexp) {
        case 'function':
            return modexp;
        case 'object':
            if (modexp === null)
                throw ErrMsg(EC.MODEXP_TYPE_MISMATCH, fncData.modFile, 'null');
            if (!fncData.handler)
                throw ErrMsg(EC.MODEXP_PROP_MISSING, fncData.modFile, '');
            const h = modexp[fncData.handler];
            if (typeof h !== 'function')
                throw ErrMsg(EC.MODEXP_PROP_MISMATCH, fncData.modFile, fncData.handler, h === null ? 'null' : typeof h);

            return h;
        default:
            throw ErrMsg(EC.MODEXP_TYPE_MISMATCH, fncData.modFile, typeof modexp);
    }
}

function funcInvoke(modexp, event, context, finish, failed, fncData) {
    try {
        const handler = getHandler(modexp, fncData);
        Promise.resolve(handler(event, context))
            .then(rval => finish(rval))
            .catch(err => failed(err, 500))
        ;
    } catch (err) {
        failed(err, 500);
    }
}

function funcFailed(error, code, request, response, fncLog, fncData, metrics) {
    metrics.onFuncError(fncData.fncName, request.method);
    if (!response.finished)
        response.status(code).send(http.STATUS_CODES[code]);
    let simple;
    try {
        simple = code !== 500 || error.message.startsWith(FAAS);
    } catch (e) {
        simple = code !== 500;
    }
    fncLog(fncData.fncName, error, simple);
}

function funcFinish(result, response, reject) {
    if (response.finished) {
        switch (result) {
            case undefined:
                break;
            case null:
                break;
            default:
                throw ErrMsg(EC.SCRIPT_END_RESPONSE);
        }
    } else {
        switch (typeof result) {
            case 'undefined':
                response.status(204).send();
                break;
            case 'object':
                if (result === null) {
                    response.end();
                } else if (Buffer.isBuffer(result)) {
                    response.send(result);
                } else if (Array.isArray(result)) {
                    response.json(result);
                } else {
                    switch (result.constructor.name) {
                        case 'Object':
                            response.json(result);
                            break;
                        case 'String':
                            formatString(result.valueOf(), response, reject);
                            break;
                        case 'Number':
                            formatNumber(result.valueOf(), response, reject);
                            break;
                        case 'Boolean':
                            formatBoolean(result.valueOf(), response, reject);
                            break;
                        default:
                            response.json(result);
                    }
                }
                break;
            case 'string':
                formatString(result, response, reject);
                break;
            case 'number':
                formatNumber(result, response, reject);
                break;
            case 'boolean':
                formatBoolean(result, response, reject);
                break;
            default:
                throw ErrMsg(EC.SCRIPT_BAD_RESULT, typeof result);
        }
    }
}

function formatString(result, response, reject) {
    if (response.get('content-type')) {
        response.end(result);
        return;
    }
    response.format({
        'text/plain': () => {
            response.send(result);
        },
        'application/json': () => {
            response.json(result);
        },
        'application/octet-stream': () => {
            response.send(Buffer.from(result));
        },
        'default': () => {
            reject(ErrMsg(EC.SCRIPT_NOT_ACCEPTED, 'string'), 406);
        }
    });
}

function formatNumber(result, response, reject) {
    response.format({
        'application/json': () => {
            response.json(result);
        },
        'text/plain': () => {
            response.send(Number(result).toString());
        },
        'default': () => {
            reject(ErrMsg(EC.SCRIPT_NOT_ACCEPTED, 'number'), 406);
        }
    });
}

function formatBoolean(result, response, reject) {
    response.format({
        'application/json': () => {
            response.json(result);
        },
        'text/plain': () => {
            response.send(result ? 'true' : 'false');
        },
        'default': () => {
            reject(ErrMsg(EC.SCRIPT_NOT_ACCEPTED, 'boolean'), 406);
        }
    });
}

