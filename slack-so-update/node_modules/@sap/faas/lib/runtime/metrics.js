'use strict';

const { Registry, Counter, Histogram, exponentialBuckets } = require('prom-client');
const {EC, ErrMsg} = require('../errors');

/**
 * @private
 */
class Metrics {

    /**
     *
     */
    constructor() {

        /**
         * @type {Registry}
         * @private
         */
        this._registry = new Registry();

        /**
         * @type {Counter}
         * @private
         */
        this._callsCounter = new Counter({
            name: 'function_calls_total',
            help: 'Number of calls to user function',
            labelNames: ['function', 'method'],
            registers: [this._registry]
        });

        /**
         * @type {Counter}
         * @private
         */
        this._errorCounter = new Counter({
            name: 'function_failures_total',
            help: 'Number of exceptions in user function',
            labelNames: ['function', 'method'],
            registers: [this._registry]
        });

        /**
         * @type {Histogram}
         * @private
         */
        this._timeHistogram = new Histogram({
            name: 'function_duration_seconds',
            help: 'Duration of user function in seconds',
            buckets: exponentialBuckets(0.001, 2, 16),
            labelNames: ['function', 'method'],
            registers: [this._registry]
        });

        /**
         * @type {Counter}
         * @private
         */
        this._activeCallsCounter = new Counter({
            name: 'function_active_total',
            help: 'Number of active calls to user function, reset on scrape',
            labelNames: ['function', 'method'],
            registers: [this._registry]
        });

        /**
         * @type {Histogram}
         * @private
         */
        this._activeHistogram = new Histogram({
            name: 'function_active_seconds',
            help: 'Active duration of user function runtime in seconds, reset on scrape',
            buckets: exponentialBuckets(1, 2, 16),
            registers: [this._registry]
        });

        /**
         * @type {Set<function()>}
         * @private
         */
        this._activeCalls = new Set();

        /**
         * @type {?observe}
         * @private
         */
        this._activeObserve = NOP;

    }

    /**
     * @callback observe
     */

    /**
     * @param {string} fnName
     * @param {string} method
     */
    onFuncError(fnName, method) {
        this._errorCounter.inc({'function': fnName, 'method': method}, 1);
    }

    /**
     * @param {string} fnName
     * @param {string} method
     * @return {observe}
     */
    onFuncStart(fnName, method) {
        const labels = {'function': fnName, 'method': method};
        this._callsCounter.inc(labels, 1);
        this._activeCallsCounter.inc(labels, 1);
        const close = this._timeHistogram.startTimer(labels);

        if (this._activeCalls.size === 0) {
            this._activeObserve = this._activeHistogram.startTimer();
        }
        this._activeCalls.add(close);

        return () => this._onFuncEnd(close);
    }

    /**
     * @param {observe} close
     * @private
     */
    _onFuncEnd(close) {
        if (!this._activeCalls.delete(close))
            return;
        close();

        if (this._activeCalls.size === 0) {
            if (this._activeObserve === NOP) {
                console.log(ErrMsg(EC.METRICS_INCONSISTENT, 'error observing active duration'));
                process.exit(99);
            }
            this._activeObserve();
            this._activeObserve = NOP;
        }
    }

    /**
     * @param response
     */
    onHttpQuery(response) {
        // add active duration intermediate value to response
        if (this._activeObserve !== NOP) {
            this._activeObserve();
            this._activeObserve = this._activeHistogram.startTimer();
        }

        response.format({
            [this._registry.contentType]: () => {
                response.send(this._registry.metrics());
                this._activeHistogram.reset();
                this._activeCallsCounter.reset();
            },
            'application/json': () => {
                response.json(this._registry.getMetricsAsJSON());
                this._activeHistogram.reset();
                this._activeCallsCounter.reset();
            },
            'default': () => {
                response.status(406).send('Not Acceptable');
                this._activeHistogram.reset();
                this._activeCallsCounter.reset();
            }
        });

    }

}

const NOP = () => {};

module.exports = Metrics;

