'use strict';

const path = require('path');
const fs = require('fs');
const {EC, ErrMsg} = require('../errors');

module.exports = {
    createReader,
};

/**
 * @param {string} runtime
 * @param {string} srvBase
 * @param {Map<string,string>} srvKeys
 * @param {Map<string,string>} secDirs
 * @param {Map<string,string>} cfgDirs
 * @param {Map<string,Buffer>} cache
 * @return {Reader}
 * @private
 */
function createReader(runtime, srvBase, srvKeys, secDirs, cfgDirs, cache) {
    if (runtime !== 'nodejs8') {
        return {
            asyncAccess : true,
            serviceKey  : async (name, mapper) => openSKey(srvBase, srvKeys, name, cache, mapper),
            secretValue : async (name, key, mapper) => openFile('secret', name, key, secDirs, cache, mapper),
            configValue : async (name, key, mapper) => openFile('config', name, key, cfgDirs, cache, mapper),
            secretStream: async (name, key) => openStream('secret', name, key, secDirs),
            configStream: async (name, key) => openStream('config', name, key, cfgDirs)
        };
    } else {
        return {
            asyncAccess : false,
            serviceKey  : (name, mapper) => readSKey(srvBase, srvKeys, name, cache, mapper),
            secretValue : (name, key, mapper) => readFile('secret', name, key, secDirs, cache, mapper),
            configValue : (name, key, mapper) => readFile('config', name, key, cfgDirs, cache, mapper),
            secretStream: (name, key) => readStream('secret', name, key, secDirs),
            configStream: (name, key) => readStream('config', name, key, cfgDirs)
        };
    }
}

/**
 * @param {string} base
 * @param {Map<string,string>} keys
 * @param {string} name
 * @param {Map<string,Buffer>} cache
 * @param {Mapper} mapper
 * @return {Promise<*>}
 * @private
 */
function openSKey(base, keys, name, cache, mapper) {
    return new Promise((resolve, reject) => {
        try {
            const skey = keys.get(name);
            if (!skey) {
                reject(ErrMsg(EC.SKEY_LOAD_ERROR, name, 'not assigned'));
                return;
            }
            const file = path.join(base, skey);
            const data = cache.get(file);
            if (data) {
                resolve(mapper(data));
                return;
            }
            fs.readFile(file, (err, buf) => {
                if (err) {
                    reject(ErrMsg(EC.SKEY_LOAD_ERROR, name, 'not found'));
                } else {
                    buf = unpackSKey(buf);
                    cache.set(file, buf);
                    resolve(mapper(buf));
                }
            });
        } catch (err) {
            reject(ErrMsg(EC.SKEY_LOAD_ERROR, name, 'not found'));
        }
    });
}

/**
 * @param {string} base
 * @param {Map<string,string>} keys
 * @param {string} name
 * @param {Map<string,Buffer>} cache
 * @param {Mapper} mapper
 * @return {*}
 * @private
 */
function readSKey(base, keys, name, cache, mapper) {
    const skey = keys.get(name);
    if (!skey) {
        throw ErrMsg(EC.SKEY_LOAD_ERROR, name, 'not assigned');
    }
    try {
        const file = path.join(base, skey);
        let data = cache.get(file);
        if (!data) {
            data = fs.readFileSync(file);
            data = unpackSKey(data);
            cache.set(file, data);
        }
        return mapper(data);
    } catch (err) {
        throw ErrMsg(EC.SKEY_LOAD_ERROR, name, 'not found');
    }
}

/**
 * @param {Buffer} data
 */
function unpackSKey(data) {
    try {
        const v = JSON.parse(data.toString());
        return Buffer.from(JSON.stringify(v['credentials']));
    } catch(e) {
        return Buffer.from(JSON.stringify({}));
    }
}

/**
 * @param {string} kind
 * @param {string} name
 * @param {string} key
 * @param {Map<string,string>} dirs
 * @param {Map<string,Buffer>} cache
 * @param {Mapper}mapper
 * @return {Promise<*>}
 * @private
 */
function openFile(kind, name, key, dirs, cache, mapper) {
    return new Promise((resolve, reject) => {
        try {
            const dir = dirs.get(name);
            if (!dir) {
                reject(ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not assigned'));
                return;
            }
            const file = path.join(dir, key);
            const data = cache.get(file);
            if (data) {
                resolve(mapper(data));
                return;
            }
            fs.readFile(file, (err, buf) => {
                if (err) {
                    reject(ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not found'));
                } else {
                    cache.set(file, buf);
                    resolve(mapper(buf));
                }
            });
        } catch (err) {
            reject(ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not found'));
        }
    });
}

/**
 * @param {string} kind
 * @param {string} name
 * @param {string} key
 * @param {Map<string,string>} dirs
 * @param {Map<string,Buffer>} cache
 * @param {Mapper }mapper
 * @return {*}
 * @private
 */
function readFile(kind, name, key, dirs, cache, mapper) {
    const dir = dirs.get(name);
    if (!dir) {
        throw ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not assigned');
    }
    try {
        const file = path.join(dir, key);
        let data = cache.get(file);
        if (!data) {
            data = fs.readFileSync(file);
            cache.set(file, data);
        }
        return mapper(data);
    } catch (err) {
        throw ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not found');
    }
}

/**
 * @param {string} kind
 * @param {string} name
 * @param {string} key
 * @param {Map<string,string>} dirs
 * @return {Promise<Readable>}
 */
function openStream(kind, name, key, dirs) {
    return new Promise((resolve, reject) => {
        try {
            const dir = dirs.get(name);
            if (!dir) {
                reject(ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not assigned'));
                return;
            }
            const file = path.join(dir, key);
            fs.stat(file, (err, stat) => {
                if (err) {
                    reject(ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not found'));
                    return;
                }
                try {
                    stat.isFile(); // real test for existence in advance
                    resolve(fs.createReadStream(file));
                } catch (err) {
                    reject(ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not found'));
                }
            });
        } catch (err) {
            reject(ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not found'));
        }
    });
}

/**
 * @param {string} kind
 * @param {string} name
 * @param {string} key
 * @param {Map<string,string>} dirs
 * @return {Readable}
 */
function readStream(kind, name, key, dirs) {
    const dir = dirs.get(name);
    if (!dir) {
        throw ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not assigned');
    }
    try {
        const file = path.join(dir, key);
        fs.statSync(file).isFile();    // real test for existence in advance
        return /** @type {Readable} */ (fs.createReadStream(file));
    } catch (err) {
        throw ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not found');
    }
}

