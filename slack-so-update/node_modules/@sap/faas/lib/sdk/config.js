'use strict';

const path = require('path');
const fs = require('fs');
const { createReader } = require('./reader');
const { loadDeployValues } = require('./values');
const { EC, ErrMsg } = require('../errors');
const { getPackageDependencies, loadManifest, MAX_TIMEOUT_SECONDS, MIN_TIMEOUT_SECONDS } = require('../runtime/config');

/**
 * naming rules for runtime artefacts
 *
 * see: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
 * see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
 *
 * names may also be stored as label values, hence, max length of 60 characters
 *
 * @private
 */

const RUNTIME_LIST = ['nodejs8', 'nodejs10'];

const SERVICE_KEY_LIST = ['type', 'instance', 'key'];

const REGEX_ERROR_NAME = /[^-a-z0-9]|^-|-$/;
const REGEX_ERROR_KEY = /[^-.a-z0-9]|^-|^\.|-$|\.$/;

const MAX_LENGTH_NAME = 60;
const MAX_LENGTH_KEY = 60;

const MISMATCH = 'missing in orig. data';
const TYPE_MISMATCH = 'types of replace value and orig. data do not match';
const MANDATORY_VALUE_MISSING = 'mandatory value not specified in orig. data or replacement values';

module.exports = {
    createProjectConfig,
    checkRuntime,
    checkName,
    checkReplacementValues,
    isEmptyObject,
    loadManifest,
    toAbsolutePath,
    getDeployFileName,
    MISMATCH,
    TYPE_MISMATCH,
    MANDATORY_VALUE_MISSING
};

/**
 * @param {Object} options
 * @param {?FileCache} fsCache
 * @return {Config}
 * @private
 */
function createProjectConfig(options, fsCache = new Map()) {
    const startAt = options['project-folder'] || process.cwd();
    const pkgFile = searchManifest('package.json', startAt);
    const proFile = searchManifest('faas.json', startAt);
    const project = loadManifest(proFile);
    const proBase = path.dirname(proFile);
    const modBase = getModuleBase(proBase, project['library']);
    const runtime = project['runtime'];
    const srvKeys = getSrvKeyMap(project['services']);
    const secDirs = getRefDirMap('secret', proBase, project['secrets']);
    const cfgDirs = getRefDirMap('config', proBase, project['configs']);
    const depLibs = getPackageDependencies(pkgFile);
    const values = loadDeployValues(getDeployFileName(proBase, options['deploy-values']));

    return /** @type{Config} */ ({
        /* sdk */
        pkgFile: pkgFile,
        proFile: proFile,
        proBase: proBase,
        proData: project,
        values: values,
        /* runtime */
        runtime: runtime,
        fncData: readFunctionList(runtime, project['functions'], options['function-name'], modBase, depLibs, srvKeys, secDirs, cfgDirs, fsCache, values),
        srvBase: '',
        srvKeys: srvKeys,
        secDirs: secDirs,
        cfgDirs: cfgDirs,
        fsCache: fsCache,
        domain: 'localhost',
        rtmPort: Number(options['runtime-port'] || 0),
        ctlPort: Number(options['control-port'] || 0),
    });
}

function checkRuntime(name) {
    checkName('runtime', name);
    if (!RUNTIME_LIST.includes(name))
        throw ErrMsg(EC.RUNTIME_INVALID, name, RUNTIME_LIST.join(', '));
}

function checkName(kind, name) {
    if (typeof name !== 'string')
        throw ErrMsg(EC.OBJ_NAME_BAD_TYPE, kind, typeof name);
    if (name === '')
        throw ErrMsg(EC.OBJ_NAME_INITIAL, kind);
    if (name.length > MAX_LENGTH_NAME)
        throw ErrMsg(EC.OBJ_NAME_TOO_LONG, kind, name, MAX_LENGTH_NAME, name.length);
    const epos = name.search(REGEX_ERROR_NAME);
    if (epos !== -1)
        throw ErrMsg(EC.OBJ_NAME_BAD_CHAR, kind, name, name.charAt(epos), epos);
    return name;
}

function checkKey(kind, name, key) {
    if (key.length > MAX_LENGTH_KEY)
        throw ErrMsg(EC.KEY_NAME_TOO_LONG, kind, name, key, MAX_LENGTH_NAME, key.length);
    const epos = key.search(REGEX_ERROR_KEY);
    if (epos !== -1)
        throw ErrMsg(EC.KEY_NAME_BAD_CHAR, kind, name, key, key.charAt(epos), epos);
    return true;
}

/**
 * @param {Object} values
 * @param {Object} proData
 * @param {string} proBase
 * @return {Object}
 * @private
*/
function checkReplacementValues(values, proData, proBase, logging = false) {
    // services
    const serviceValues = values['service-values'];
    const serviceRawData = proData['services'];
    let mismatchObjServices = {};

    if (!isEmptyObject(serviceValues) && serviceRawData) {
        let { serviceData, mandatoryMissingServiceKeys } = evaluateService(serviceRawData, serviceValues);

        const compareMismatchObjServices = compare(serviceValues, serviceData);
        mismatchObjServices = mergeDeep(mandatoryMissingServiceKeys, compareMismatchObjServices);
    } else if (!isEmptyObject(serviceValues)) {
        mismatchObjServices = serviceValues;
    }

    // configs
    const configValues = values['config-values'];
    const configRawData = proData['configs'];
    let mismatchObjConfigs = {};
    if (!isEmptyObject(configValues) && configRawData) {
        const configData = getAssetData(configRawData, proBase);
        mismatchObjConfigs = compare(configValues, configData);
    } else if (!isEmptyObject(configValues)) {
        mismatchObjConfigs = configValues;
    }

    // secrets
    const secretValues = values['secret-values'];
    const secretRawData = proData['secrets'];
    let mismatchObjSecrets = {};
    if (!isEmptyObject(secretValues) && secretRawData) {
        const secretData = getAssetData(secretRawData, proBase);
        mismatchObjSecrets = compare(secretValues, secretData);
    } else if (!isEmptyObject(secretValues)) {
        mismatchObjSecrets = secretValues;
    }


    // Logging
    if (logging) {
        if (serviceRawData == null && !isEmptyObject(mismatchObjServices)) {
            console.log('No services available in the provided data but found replacements:\n  ' + JSON.stringify(mismatchObjServices, null, 4).replace(/\n\r?/g, '\n  '));
        } else if (!isEmptyObject(mismatchObjServices)) {
            const warning = 'Warning: mismatched service replacements';
            console.log(warning + '\n  ' + JSON.stringify(mismatchObjServices, null, 4).replace(/\n\r?/g, '\n  '));
        }

        if (configRawData == null && !isEmptyObject(mismatchObjConfigs)) {
            console.log('No configs available in the provided data but found replacements:\n  ' + JSON.stringify(mismatchObjConfigs, null, 4).replace(/\n\r?/g, '\n  '));
        } else if (!isEmptyObject(mismatchObjConfigs)) {
            const warning = 'Warning: mismatched config replacements';
            console.log(warning + '\n  ' + JSON.stringify(mismatchObjConfigs, null, 4).replace(/\n\r?/g, '\n  '));
        }

        if (secretRawData == null && !isEmptyObject(mismatchObjSecrets)) {
            console.log('No secrets available in the provided data but found replacements:\n  ' + JSON.stringify(mismatchObjSecrets, null, 4).replace(/\n\r?/g, '\n  '));
        } else if (!isEmptyObject(mismatchObjSecrets)) {
            const warning = 'Warning: mismatched secret replacements';
            console.log(warning + '\n  ' + JSON.stringify(mismatchObjSecrets, null, 4).replace(/\n\r?/g, '\n  '));
        }
    }

    return {
        services: mismatchObjServices,
        configs: mismatchObjConfigs,
        secrets: mismatchObjSecrets
    };
}

/**
 * @param {string} base
 * @param {string} library
 * @return {string}
 * @private
 */
function getModuleBase(base, library) {
    if (library === undefined)
        return base;
    if (typeof library === 'string')
        return path.normalize(path.join(base, library));
    throw ErrMsg(EC.LIBRARY_INVALID, typeof library);
}

/**
 * @param {string} runtime
 * @param {Object} fncList
 * @param {string} fncName
 * @param {string} modBase
 * @param {Map<string, string>} depLibs
 * @param {Map<string, string>} srvKeys
 * @param {Map<string, string>} secDirs
 * @param {Map<string, string>} cfgDirs
 * @param {FileCache} fsCache
 * @param {Object} values
 * @return {Array<FncData>}
 * @private
 */
function readFunctionList(runtime, fncList, fncName, modBase, depLibs, srvKeys, secDirs, cfgDirs, fsCache, values) {
    if (fncList === undefined)
        return [];
    if (typeof fncList !== 'object')
        throw ErrMsg(EC.FUNC_LIST_INVALID, typeof fncList);

    const data = [];
    if (fncName === undefined || fncName === '') for (const defined of Object.keys(fncList)) {
        data.push(readFunctionData(runtime, fncList, defined, modBase, depLibs, srvKeys, secDirs, cfgDirs, fsCache, values));
    } else if (checkName('function', fncName)) {
        data.push(readFunctionData(runtime, fncList, fncName, modBase, depLibs, srvKeys, secDirs, cfgDirs, fsCache, values));
    }
    return data;
}

/**
 * @param {string} runtime
 * @param {Object} fncList
 * @param {string} fncName
 * @param {string} modBase
 * @param {Map<string, string>} depLibs
 * @param {Map<string, string>} srvKeys
 * @param {Map<string, string>} secDirs
 * @param {Map<string, string>} cfgDirs
 * @param {FileCache} fsCache
 * @param {Object} values
 * @return {FncData}
 * @private
 */
function readFunctionData(runtime, fncList, fncName, modBase, depLibs, srvKeys, secDirs, cfgDirs, fsCache, values) {
    checkName('function', fncName);

    const data = fncList[fncName];
    if (!data)
        throw ErrMsg(EC.FUNC_UNDEFINED, fncName);

    const modFile = data['module'];
    if (!modFile)
        throw ErrMsg(EC.MODULE_UNDEFINED, fncName);
    if (typeof modFile !== 'string')
        throw ErrMsg(EC.MODULE_INVALID, fncName, typeof modFile);

    const handler = data['handler'];
    if (handler && typeof handler !== 'string')
        throw ErrMsg(EC.HANDLER_INVALID, fncName, typeof handler);

    const timeout = data['timeout'] || MAX_TIMEOUT_SECONDS;
    if (typeof timeout !== 'number')
        throw ErrMsg(EC.TIMEOUT_INVALID, fncName, typeof handler);
    if (timeout < MIN_TIMEOUT_SECONDS || timeout > MAX_TIMEOUT_SECONDS)
        throw ErrMsg(EC.TIMEOUT_RANGE, fncName, MIN_TIMEOUT_SECONDS, MAX_TIMEOUT_SECONDS, timeout);

    let maxBody = data['maxBody'] || '1MB';
    if (typeof maxBody != 'string')
        throw ErrMsg(EC.MAX_BODY_INVALID, fncName, typeof maxBody);


    const srvBind = readBindings(fncName, 'service', data['services'], srvKeys);
    const secBind = readBindings(fncName, 'secret', data['secrets'], secDirs);
    const cfgBind = readBindings(fncName, 'config', data['configs'], cfgDirs);

    return /** @type{FncData} */{
        fncName: fncName,
        modFile: path.normalize(path.join(modBase, modFile)),
        handler: handler,
        httpApi: !!data['httpApi'],
        depLibs: depLibs,
        reader: createReader(runtime, srvBind, secBind, cfgBind, fsCache, values),
        timeout: timeout * 1000,
        maxBody: maxBody
    };
}

/**
 * @param {string} func
 * @param {string} kind
 * @param {Array<string>} bind
 * @param {Map<string,*>} list
 * @return {Map<string,*>}
 * @private
 */
function readBindings(func, kind, bind, list) {
    if (bind === undefined)
        return new Map();
    if (!Array.isArray(bind))
        throw ErrMsg(EC.BINDING_INVALID, func, kind, typeof bind);

    const result = new Map();
    for (const name of bind) {
        const item = list.get(name);
        if (item)
            result.set(name, item);
        else
            throw ErrMsg(EC.BINDING_UNRESOLVED, func, kind, name);
    }
    return result;
}

/**
 * @param {string} fname
 * @param {string} start
 * @return {string}
 * @private
 */
function searchManifest(fname, start) {
    const s = toAbsolutePath(start);
    let d = fs.statSync(s).isDirectory() ? s : path.dirname(s);
    let f = '';
    while (d !== f) {
        f = path.join(d, fname);
        try {
            if (fs.statSync(f).isFile()) return f;
        } catch (e) {
            f = '';
        }
        f = d;
        d = path.dirname(d);
    }
    throw ErrMsg(EC.FILE_NOT_FOUND, fname);
}

/**
 * @param {string} name
 * @param {object} data
 * @param {string} field
 * @return {string}
 */
function getSrvKeyVal(name, data, field) {
    const v = data[field];
    switch (typeof v) {
        case 'undefined':
            return '';
        case 'string':
            const p = v.search(REGEX_ERROR_NAME); // check as strict as any name, in particular not '.'
            if (p !== -1)
                throw ErrMsg(EC.SKEY_VAL_BAD_CHAR, name, field, v.charAt(p), p);
            return v;
        default:
            throw ErrMsg(EC.SKEY_VAL_BAD_TYPE, name, field, typeof v);
    }
}

/**
 * @param {Object} dict
 * @return {Map<string, string>}
 */
function getSrvKeyMap(dict) {
    const result = new Map();
    if (dict) {
        if (typeof dict !== 'object')
            throw ErrMsg(EC.BIND_DICT_ERROR, 'service', typeof dict);
        for (const [name, data] of Object.entries(dict)) {
            checkName('service', name);
            const v = [
                getSrvKeyVal(name, data, 'type'),
                getSrvKeyVal(name, data, 'instance'),
                getSrvKeyVal(name, data, 'key'),
            ];
            result.set(name, v.join('.'));
        }
    }
    return result;
}

/**
 * @param {string} kind
 * @param {string} base
 * @param {Object} dict
 * @return {Map<string, string>}
 * @private
 */
function getRefDirMap(kind, base, dict) {
    const result = new Map();

    if (dict) {
        if (typeof dict !== 'object')
            throw ErrMsg(EC.BIND_DICT_ERROR, kind, typeof dict);

        let v, p, s;
        for (const k of Object.keys(dict)) {
            checkName(kind, k);

            v = dict[k];
            if (!v || typeof v !== 'object')
                throw ErrMsg(EC.BIND_ITEM_ERROR, kind, k, typeof v);
            if (typeof v['source'] !== 'string')
                throw ErrMsg(EC.BIND_SOURCE_ERROR, kind, k, typeof v['source']);

            p = path.normalize(path.join(base, v['source']));
            try {
                s = fs.statSync(p);
            } catch (e) {
                throw ErrMsg(EC.BIND_SRC_DIR_ERROR, kind, k, p);
            }
            if (!s.isDirectory()) {
                throw ErrMsg(EC.BIND_SRC_DIR_ERROR, kind, k, p);
            }
            for (const item of fs.readdirSync(p)) {
                if (fs.statSync(path.join(p, item)).isFile())
                    checkKey(kind, k, item);
            }
            result.set(k, p);
        }
    }

    return result;
}

/**
 * @param {string} proBase
 * @param {string} valFile
 * @return {string}
 * @private
 */
function getDeployFileName(proBase, valFile) {
    if (!valFile)
        return '';
    const file = path.parse(valFile);
    if (!file.dir)
        return path.join(proBase, 'deploy', valFile);
    return toAbsolutePath(valFile);
}

/**
 * @param {string} start
 * @return {string}
 * @private
 */
function toAbsolutePath(start) {
    if (path.isAbsolute(start)) {
        return start;
    } else if (start.startsWith('.')) {
        return path.normalize(path.join(process.cwd(), start));
    } else if (start.startsWith('~')) {
        return path.normalize(start.replace(/^~/, process.env.HOME));
    } else if (start.startsWith('%USERPROFILE%')) {
        return path.normalize(start.replace('%USERPROFILE%', process.env.USERPROFILE));
    } else {
        throw ErrMsg(EC.PATH_INVALID, start);
    }
}

function loadSource(file) {
    let data;
    try {
        if (!file) return '';
        data = fs.readFileSync(file, 'utf8');
    } catch (e) {
        throw ErrMsg(EC.FILE_NOT_FOUND, file);
    }
    return data;
}

function getAssetData(rawData, proBase) {
    let data = {};
    for (const topLevelSrvKey of Object.keys(rawData)) {
        const dir = path.join(proBase, rawData[topLevelSrvKey].source);

        const src = {};
        fs.readdirSync(dir).forEach(file => {
            src[file] = loadSource(path.join(dir, file));
            try {
                src[file] = JSON.parse(src[file]);
            } catch (e) { // it is not a JSON object
            }
        });
        if (Object.keys(src).length === 0) {
            continue;
        }

        data[topLevelSrvKey] = src;
    }
    return data;
}

function isObject(val) {
    return val && val.constructor.name === 'Object';
}

function isSimpleValue(val) {
    return typeof val !== 'object' && typeof val !== 'undefined';
}

function isEmptyObject(obj) {
    return Object.keys(obj).length === 0 && obj.constructor === Object;
}

function targetIsFlatSuperObjectOfSource(source, target) {
    return Object.keys(source).every(function (key) {
        if (target.hasOwnProperty(key)) {
            if (isSimpleValue(target[key])) {
                return true;
            }
        }
        return false;
    });

}

function compare(obj1 = {}, obj2 = {}) {
    const output = {},
        merged = { ...obj1, ...obj2 }; // has properties of both

    for (const key in merged) {
        const value1 = obj1[key],
            value2 = obj2[key];

        if (value1 && !value2) { // prop present in values.yaml but not in actual data
            output[key] = MISMATCH;
        } else if (!value1 && value2) { // no matching key in values.yaml --> no replacement
            continue;
        } else if (value1.constructor.name !== value2.constructor.name) {
            switch (obj1.constructor.name) {
                case 'Array':
                    output[`index ${key}`] = TYPE_MISMATCH;
                    break;
                default:
                    output[key] = TYPE_MISMATCH;
                    break;
            }
        } else if (isObject(value2) && isObject(value1) && targetIsFlatSuperObjectOfSource(value1, value2)) {
            continue;
        } else if (!isSimpleValue(value2)) {
            let differObj = compare(value1, value2); // recursively call
            if (!isEmptyObject(differObj)) {
                output[key] = differObj;
            }
        }
    }

    return output;
}

function evaluateService(serviceRawData, serviceValues) {
    let serviceData = {};
    let mandatoryMissingServiceKeys = {};
    for (const [srvKey, srvValue] of Object.entries(serviceRawData)) {
        serviceData[srvKey] = {};
        mandatoryMissingServiceKeys[srvKey] = {};
        for (const key of SERVICE_KEY_LIST) {
            let serviceRawDataValueExists = serviceRawData[srvKey].hasOwnProperty(key);
            let serviceValueExists = serviceValues[srvKey].hasOwnProperty(key);
            if (!serviceRawDataValueExists && !serviceValueExists) {
                mandatoryMissingServiceKeys[srvKey][key] = MANDATORY_VALUE_MISSING;
            } else if (!serviceRawDataValueExists) {
                serviceData[srvKey][key] = 'PRESENT_IN_VALUES.YAML';
            }
        }
    }
    return {
        serviceData,
        mandatoryMissingServiceKeys
    };
}

function mergeDeep(target, ...sources) {
    if (!sources.length) return target;
    const source = sources.shift();

    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key])) {
                if (!target[key]) Object.assign(target, { [key]: {} });
                mergeDeep(target[key], source[key]);
            } else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }

    return mergeDeep(target, ...sources);
}