'use strict';

const path = require('path');
const fs = require('fs');
const {execSync} = require('child_process');
const {Readable, PassThrough} = require('stream');
const {splitServiceValue, replaceServiceKey, replaceContent} = require('./values');
const {EC, ErrMsg} = require('../errors');

module.exports = {
    createReader
};

/**
 * @param {string} runtime
 * @param {Map<string,string>} srvKeys
 * @param {Map<string,string>} secDirs
 * @param {Map<string,string>} cfgDirs
 * @param {Map<string,Buffer>} cache
 * @param {Object} values
 * @return {Reader}
 * @private
 */
function createReader(runtime, srvKeys, secDirs, cfgDirs, cache, values) {
    if (runtime !== 'nodejs8') {
        return {
            asyncAccess: true,
            serviceKey: async (name, mapper) => openSKey(srvKeys, name, cache, values['service-values'], mapper),
            secretValue: async (name, key, mapper) => openFile('secret', name, key, secDirs, cache, values['secret-values'], mapper),
            configValue: async (name, key, mapper) => openFile('config', name, key, cfgDirs, cache, values['config-values'], mapper),
            secretStream: async (name, key) => openFile('secret', name, key, secDirs, cache, values['secret-values'], asStream),
            configStream: async (name, key) => openFile('config', name, key, cfgDirs, cache, values['config-values'], asStream)
        };
    } else {
        return {
            asyncAccess: false,
            serviceKey: (name, mapper) => readSKey(srvKeys, name, cache, values['service-values'], mapper),
            secretValue: (name, key, mapper) => readFile('secret', name, key, secDirs, cache, values['secret-values'], mapper),
            configValue: (name, key, mapper) => readFile('config', name, key, cfgDirs, cache, values['config-values'], mapper),
            secretStream: (name, key) => readFile('secret', name, key, secDirs, cache, values['secret-values'], asStream),
            configStream: (name, key) => readFile('config', name, key, cfgDirs, cache, values['config-values'], asStream)
        };
    }
}

/**
 * @param {Map<string,string>} keys
 * @param {string} name
 * @param {Map<string,Buffer>} cache
 * @param {Object} values
 * @param {Mapper} mapper
 * @return {Promise<*>}
 * @private
 */
function openSKey(keys, name, cache, values, mapper) {
    return new Promise((resolve, reject) => {
        try {
            resolve(readSKey(keys, name, cache, values, mapper));
        } catch (err) {
            reject(err);
        }
    });
}

/**
 * @param {Map<string,string>} keys
 * @param {string} name
 * @param {Map<string,Buffer>} cache
 * @param {Object} values
 * @param {Mapper} mapper
 * @return {*}
 * @private
 */
function readSKey(keys, name, cache, values, mapper) {
    let data = cache.get(name); // secrets and configs use one absolute file path instead, hence no clash possible
    if (!data) {
        const skey = keys.get(name);
        if (!skey) {
            throw ErrMsg(EC.SKEY_LOAD_ERROR, name, 'not assigned');
        }
        const sref = splitServiceValue(skey);
        if (values) {
            replaceServiceKey(sref, values, name);
        }
        data = readSKeyCF(name, sref);
        cache.set(name, data);
    }
    return mapper(data);
}

/**
 * @param {string} name
 * @param {Object} sref
 * @return {Buffer}
 * @private
 */
function readSKeyCF(name, sref) {
    let stdout, jsData;
    try {
        stdout = /** @type {Buffer} */ (
            execSync(`cf curl /v2/service_instances/${sref.instance}/service_keys?q=name%3A${sref.key}`, {
                stdio: ['pipe', 'pipe', 'ignore'],
                encoding: 'buffer',
                windowsHide: true
            })
        );
    } catch (e) {
        throw ErrMsg(EC.SKEY_LOAD_ERROR, name, `failed to execute command \'cf curl\' , run cf login, try \'cf service-key ${sref.instance} ${sref.key}\'`);
    }
    try {
        jsData = JSON.parse(stdout.toString());
    } catch(e) {
        throw ErrMsg(EC.SKEY_LOAD_ERROR, name, 'cf curl response format invalid');
    }
    if (!jsData || typeof jsData !== 'object') {
        throw ErrMsg(EC.SKEY_LOAD_ERROR, name, 'cf curl response content invalid');
    }
    if (jsData['error_code']) {
        const desc = jsData['description'];
        throw ErrMsg(EC.SKEY_LOAD_ERROR, name, typeof desc === 'string' ? desc.toLowerCase() : 'not found');
    }
    try {
        for (const res of jsData['resources']) {
            const entity = res['entity'];
            if (entity['name'] !== sref.key) {
                continue;
            }
            const val = entity['credentials'];
            if (!val || typeof val !== 'object') {
                continue;
            }
            return Buffer.from(JSON.stringify(val));
        }
    } catch(e) {
        throw ErrMsg(EC.SKEY_LOAD_ERROR, name, 'cf curl response content invalid');
    }

    throw ErrMsg(EC.SKEY_LOAD_ERROR, name, 'cf curl response content mismatch');
}

/**
 * @param {string} kind
 * @param {string} name
 * @param {string} key
 * @param {Map<string,string>} dirs
 * @param {Map<string,Buffer>} cache
 * @param {Object} values
 * @param {Mapper}mapper
 * @return {Promise<*>}
 * @private
 */
function openFile(kind, name, key, dirs, cache, values, mapper) {
    return new Promise((resolve, reject) => {
        try {
            resolve(readFile(kind, name, key, dirs, cache, values, mapper));
        } catch (err) {
            reject(err);
        }
    });
}

/**
 * @param {string} kind
 * @param {string} name
 * @param {string} key
 * @param {Map<string,string>} dirs
 * @param {Map<string,Buffer>} cache
 * @param {Object} values
 * @param {Mapper}mapper
 * @return {*}
 * @private
 */
function readFile(kind, name, key, dirs, cache, values, mapper) {
    const dir = dirs.get(name);
    if (!dir) {
        throw ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not assigned');
    }
    try {
        const file = path.join(dir, key);
        let data = cache.get(file);
        if (!data) {
            data = fs.readFileSync(file);
            if (values) data = replaceContent(data, values, name, key);
            cache.set(file, data);
        }
        return mapper(data);
    } catch (err) {
        throw ErrMsg(EC.DATA_LOAD_ERROR, kind, name, key, 'not found');
    }
}

/**
 * @param {Buffer} out
 * @return {Readable}
 * @private
 */
function asStream(out) {
    const stream = new PassThrough();
    stream.end(out);
    return /**@type{Readable}*/ (stream);
}

