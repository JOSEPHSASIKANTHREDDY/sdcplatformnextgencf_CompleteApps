'use strict';

const path = require('path');
const fs = require('fs');
const yaml = require('js-yaml');
const {EC, ErrMsg, LogMsg} = require('../errors');

const MAX_DEPLOY_ENTRY_SIZE = 0x100000;
const MAX_DEPLOY_VALUE_SIZE = 4096;
const VALUES_YAML_INDENT = 2;
const VALUES_YAML_LINE_WIDTH = 4096;
const EMPTY_VALUES = {
    'service-values': {},
    'secret-values': {},
    'config-values': {}
};

module.exports = {
    splitServiceValue,
    initDeployValues,
    loadDeployValues,
    replaceServiceKey,
    replaceContent,
};

/**
 * @param {Map<string,string>} srvKeys
 * @param {Map<string,string>} secDirs
 * @param {Map<string,string>} cfgDirs
 * @param {Array<string>} log
 * @return {string}
 * @private
 */
function initDeployValues(srvKeys, secDirs, cfgDirs, log) {
    return yaml.safeDump(
        {
            'service-values': findServiceValues(srvKeys, log),
            'secret-values' : findDeployValues('secret', secDirs, log),
            'config-values' : findDeployValues('config', cfgDirs, log)
        },
        {
            indent: VALUES_YAML_INDENT,
            skipInvalid: true,
            flowLevel: -1,
            noRefs: true,
            noCompatMode: true,
            lineWidth: VALUES_YAML_LINE_WIDTH
        }
    );
}

/**
 * @param {string} data
 * @return {Object}
 */
function splitServiceValue(data) {
    const v = data.split('.');
    return {
        type: (v.length > 0 && v[0]) ? v[0] : '',
        instance: (v.length > 1 && v[1]) ? v[1] : '',
        key: (v.length > 2 && v[2]) ? v[2] : ''
    };
}

/**
 * @param {Map<string, string>} srvKeys
 * @param {Array<string>} log
 * @return {Object}
 * @private
 */
function findServiceValues(srvKeys, log) {
    const result = {};
    for (const [name, data] of srvKeys) {
        let entry = null;
        try {
            entry = splitServiceValue(data);
        } catch (e) {
            entry = {
                type: '',
                instance: '',
                key: ''
            };
        }
        result[name] = entry;
    }
    return result;
}

/**
 * @param {string} kind
 * @param {Map<string, string>} dirs
 * @param {Array<string>} log
 * @return {Object}
 * @private
 */
function findDeployValues(kind, dirs, log) {
    const result = {};
    for (const [name, dir] of dirs) {
        let entry = {};
        for (const item of fs.readdirSync(dir, {encoding: 'utf-8'})) {
            const file = path.join(dir, item);
            const stat = fs.statSync(file);
            let value = null;

            if (!stat.isFile()) {
                continue;
            }

            if (stat.size > MAX_DEPLOY_ENTRY_SIZE) {
                log.push(LogMsg(EC.SKIP_FILE_TOO_BIG, kind, name, item, stat.size));
                continue;
            }

            try {
                const data = fs.readFileSync(file).toString();
                const info = path.parse(item);

                switch (info.ext) {
                    case '':
                        try {
                            value = checkDeployValueJSON(kind, name, log, stat, info, data);
                        } catch (e) {
                            value = checkDeployValueString(kind, name, log, stat, info, data);
                        }
                        break;
                    case '.json':
                        value = checkDeployValueJSON(kind, name, log, stat, info, data);
                        break;
                    case '.yaml':
                        value = checkDeployValueYAML(kind, name, log, stat, info, data);
                        break;
                    case '.txt':
                        value = checkDeployValueString(kind, name, log, stat, info, data);
                        break;
                    default:
                        log.push(LogMsg(EC.SKIP_FILE_TYPE, kind, name, item, info.ext));
                        continue;
                }

            } catch (e) {
                log.push(LogMsg(EC.SKIP_FILE_VAL_READ, kind, name, item, e.message));
                continue;
            }

            if (value !== null) {
                entry[item] = value;
            }
        }
        if (Object.keys(entry).length) {
            result[name] = entry;
        }
    }
    return result;
}

function checkDeployValueString(kind, name, log, stat, info, data) {
    if (stat.size > MAX_DEPLOY_VALUE_SIZE) {
        log.push(LogMsg(EC.SKIP_FILE_VAL_SIZE, kind, name, info.base, stat.size));
        return null;
    }
    return data;
}

function checkDeployValueJSON(kind, name, log, stat, info, data) {
    return JSON.parse(data);
}

function checkDeployValueYAML(kind, name, log, stat, info, data) {
    return yaml.safeLoad(data);
}

/**
 * @param {string} file
 * @return {Object}
 * @private
 */
function loadDeployValues(file) {
    let data, rval;
    try {
        if (!file) return EMPTY_VALUES;
        data = fs.readFileSync(file, 'utf8');
    } catch (e) {
        throw ErrMsg(EC.FILE_NOT_FOUND, file);
    }
    try {
        rval = yaml.safeLoad(data);
    } catch (e) {
        throw ErrMsg(EC.FILE_NOT_VALID, file, e.message);
    }
    switch (typeof rval) {
        case 'undefined':
            return EMPTY_VALUES;
        case 'object':
            return rval ? Object.assign({}, EMPTY_VALUES, rval) : EMPTY_VALUES;
        default:
            throw ErrMsg(EC.FILE_NOT_VALID, file, 'expected yaml format, object at top level');
    }
}

/**
 * @param {Object} service
 * @param {Object} replace
 * @param {string} name
 * @return {Object}
 * @private
 */
function replaceServiceKey(service, replace, name) {
    if (replace) {
        const srvRepl = replace[name];
        if (srvRepl && typeof srvRepl === 'object') {
            replaceStringProp(service, srvRepl, 'type');
            replaceStringProp(service, srvRepl, 'instance');
            replaceStringProp(service, srvRepl, 'key');
        }
    }
    return service;
}

function replaceStringProp(base, repl, field) {
    const r = repl[field];
    if (r && typeof r === 'string') {
        base[field] = r;
    }
}

/**
 * @param {Buffer} content
 * @param {Object} replace
 * @param {string} name
 * @param {string} key
 * @return {Buffer}
 * @private
 */
function replaceContent(content, replace, name, key) {
    if (!replace)
        return content;

    const item = replace[name];
    if (!item)
        return content;

    const val = item[key];
    switch (typeof val) {
        case 'object':
            if (val === null)
                return Buffer.from(JSON.stringify(val));
            if (Array.isArray(val))
                return Buffer.from(JSON.stringify(val));

            let obj;
            switch (path.parse(key).ext) {
                case '':
                    try {
                        obj = JSON.parse(content.toString('utf8'));
                    } catch (e) {
                        return Buffer.from(JSON.stringify(val));
                    }
                    return Buffer.from(JSON.stringify(replaceElement(obj, val)));
                case '.json':
                    obj = JSON.parse(content.toString('utf8'));
                    return Buffer.from(JSON.stringify(replaceElement(obj, val)));
                case '.yaml':
                    obj = yaml.safeLoad(content.toString('utf8'));
                    return Buffer.from(yaml.safeDump(replaceElement(obj, val), {
                        indent: VALUES_YAML_INDENT,
                        skipInvalid: true,
                        lineWidth: VALUES_YAML_LINE_WIDTH
                    }));
                case '.txt':
                    return Buffer.from(JSON.stringify(val));
            }
            return Buffer.from(JSON.stringify(val));
        case 'string':
            return Buffer.from(val);
        case 'number':
            return Buffer.from(Number(val).toString());
        case 'boolean':
            return Buffer.from(val ? 'true' : 'false');
        default:
            return content;
    }
}

/**
 * @param {*} element
 * @param {*} replace
 * @return {*}
 * @private
 */
function replaceElement(element, replace) {
    switch (typeof element) {
        case 'object':
            if (element === null)
                break;
            if (Array.isArray(element))
                break;
            if (typeof replace !== 'object')
                break;
            for (const k of Object.keys(element))
                element[k] = replaceElement(element[k], replace[k]);
            return element;
        case 'string':
            break;
        case 'number':
            break;
        case 'boolean':
            break;
    }
    return replace === undefined ? element : replace;
}

