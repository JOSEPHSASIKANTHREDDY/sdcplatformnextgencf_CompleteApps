'use strict';

const { ErrMsg, EC } = require('./errors.js');
const path = require('path');
const server = require('./http/server.js');
const config = require('./sdk/config');
const { createContext } = require('./runtime/context');
const { createReader } = require('./sdk/reader');

module.exports = {
    test
};

/**
 * Starts a local faas server based on the given configuration, executes the (async) test method, closes the server.
 * @param {TestDone} done - A callback to end test async, usually provided by test framework, e.g. mocha
 * @param {TestOptions|Object} options - Options to define test setup
 * @param {TestExec} execute - A callback to execute test calls while runtime server is listening
 */
function test(done, options, execute) {
    const cfg = config.createProjectConfig({
        'project-folder': resolveProjectFolder(options['project-folder'], 3), // 'Error >> 'caller()' >> 'test'
        'function-name' : options['function-name'],
        'deploy-values' : (options['deploy-values']) ? resolveProjectFolder(options['deploy-values' ], 3) : '',
        'runtime-port'  : 0,
        'control-port'  : 0
    });
    const ctx = createContext(cfg, /**@type{FncData}*/({
        fncName: '',
        timeout: 180000,
        httpApi: false,
        reader : createReader(cfg.runtime, cfg.srvKeys, cfg.secDirs, cfg.cfgDirs, cfg.fsCache, cfg.values),
    }));

    const log = [];
    function fncLog(func, error, short) {
        log.push(error);
    }

    // noinspection JSUnusedLocalSymbols
    function skipLog(req, res) {
        return true;
    }

    // noinspection JSUnusedLocalSymbols
    const {rtmSrv, ctlSrv, fnList, close} = server.listen(cfg, fncLog, skipLog);

    rtmSrv.on('listening', () => {
        Promise.resolve(execute(ctx))
            .then(() => {
                close(done);
            })
            .catch((e) => {
                close(() => done(log.length ? log[log.length - 1] : e));
            })
        ;
    });
}

/**
 * @private
 */
function resolveProjectFolder(src, level) {
    if (!src)
        return getTestFolderFromCallstack(level + 1);
    if (typeof src !== 'string')
        throw ErrMsg(EC.FILE_NOT_VALID);
    if (src.startsWith('.'))
        return path.join(getTestFolderFromCallstack(level + 1), src);
    return src;
}

/**
 * @private
 */
function getTestFolderFromCallstack(level) {
    const stack = (new Error()).stack.split('\n');
    const entry = stack[level];
    const cfile = entry.replace(/.*\(/, '').replace(/:\d*:\d*\)/, '');
    return path.dirname(cfile);
}

